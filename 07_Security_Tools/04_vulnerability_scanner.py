#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Vulnerability Scanner Tool in Python for Cybersecurity
This script implements a vulnerability scanner that detects common
security vulnerabilities in systems and applications.
Perfect for beginners!
"""

import socket
import requests
import re
import time
import json
import xml.etree.ElementTree as ET
from datetime import datetime
from collections import defaultdict
import subprocess

class VulnerabilityScanner:
    """Vulnerability scanner for systems and applications"""
    
    def __init__(self, target, port=80, timeout=10):
        """
        Initialize vulnerability scanner
        
        Args:
            target: Target IP address or hostname
            port: Target port to scan
            timeout: Connection timeout in seconds
        """
        self.target = target
        self.port = port
        self.timeout = timeout
        self.vulnerabilities = []
        self.services = []
        
        # Common vulnerabilities signatures
        self.vulnerability_signatures = {
            'open_ports': [],
            'software_versions': [],
            'http_headers': [],
            'web_vulnerabilities': []
        }
        
        self._load_signatures()
        
    def _load_signatures(self):
        """Load vulnerability signatures from definitions"""
        # Common HTTP security headers that should be present
        self.vulnerability_signatures['http_headers'] = [
            {
                'name': 'Missing HSTS Header',
                'type': 'http_header',
                'description': 'HTTP Strict Transport Security header not found',
                'severity': 'medium',
                'check': lambda headers: 'strict-transport-security' not in [h.lower() for h in headers]
            },
            {
                'name': 'Missing X-Frame-Options',
                'type': 'http_header',
                'description': 'X-Frame-Options header not found',
                'severity': 'medium',
                'check': lambda headers: 'x-frame-options' not in [h.lower() for h in headers]
            },
            {
                'name': 'Missing X-Content-Type-Options',
                'type': 'http_header',
                'description': 'X-Content-Type-Options header not found',
                'severity': 'low',
                'check': lambda headers: 'x-content-type-options' not in [h.lower() for h in headers]
            },
            {
                'name': 'Missing X-XSS-Protection',
                'type': 'http_header',
                'description': 'X-XSS-Protection header not found',
                'severity': 'low',
                'check': lambda headers: 'x-xss-protection' not in [h.lower() for h in headers]
            }
        ]
        
        # Common web application vulnerabilities
        self.vulnerability_signatures['web_vulnerabilities'] = [
            {
                'name': 'Directory Listing Enabled',
                'type': 'web',
                'description': 'Web server directory listing is enabled',
                'severity': 'medium',
                'check': lambda response: 'Index of' in response.text
            },
            {
                'name': 'Default Page Detected',
                'type': 'web',
                'description': 'Default web server page detected',
                'severity': 'low',
                'check': lambda response: any(pattern in response.text.lower() 
                                            for pattern in ['apache', 'nginx', 'iis', 'default page'])
            }
        ]
        
    def _check_port(self, port):
        """Check if port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, port))
            sock.close()
            return True
        except:
            return False
            
    def _check_http(self):
        """Check HTTP/HTTPS service on target port"""
        try:
            url = f"http://{self.target}:{self.port}"
            response = requests.get(url, timeout=self.timeout)
            
            self.services.append({
                'protocol': 'HTTP',
                'port': self.port,
                'version': 'HTTP/1.1',
                'status': 'running'
            })
            
            self._check_http_vulnerabilities(response)
            
            return response
            
        except Exception as e:
            print(f"Error checking HTTP service: {e}")
            return None
            
    def _check_https(self):
        """Check HTTPS service on target port"""
        try:
            url = f"https://{self.target}:{self.port}"
            response = requests.get(url, timeout=self.timeout, verify=False)
            
            self.services.append({
                'protocol': 'HTTPS',
                'port': self.port,
                'version': 'HTTP/1.1',
                'status': 'running'
            })
            
            self._check_http_vulnerabilities(response)
            
            return response
            
        except Exception as e:
            print(f"Error checking HTTPS service: {e}")
            return None
            
    def _check_http_vulnerabilities(self, response):
        """Check for HTTP-related vulnerabilities"""
        print(f"Checking for HTTP vulnerabilities...")
        
        # Check security headers
        headers = [h.lower() for h in response.headers.keys()]
        
        for sig in self.vulnerability_signatures['http_headers']:
            if sig['check'](headers):
                self.vulnerabilities.append({
                    'name': sig['name'],
                    'type': sig['type'],
                    'description': sig['description'],
                    'severity': sig['severity'],
                    'location': response.url,
                    'cvss': 5.0
                })
                print(f"  ⚠️  {sig['name']} ({sig['severity']})")
                
        # Check web vulnerabilities
        for sig in self.vulnerability_signatures['web_vulnerabilities']:
            if sig['check'](response):
                self.vulnerabilities.append({
                    'name': sig['name'],
                    'type': sig['type'],
                    'description': sig['description'],
                    'severity': sig['severity'],
                    'location': response.url,
                    'cvss': 4.0
                })
                print(f"  ⚠️  {sig['name']} ({sig['severity']})")
                
    def _check_ssh(self):
        """Check SSH service on port 22"""
        if self.port == 22 or self._check_port(22):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                sock.connect((self.target, 22))
                
                banner = sock.recv(1024).decode('utf-8').strip()
                sock.close()
                
                self.services.append({
                    'protocol': 'SSH',
                    'port': 22,
                    'version': banner,
                    'status': 'running'
                })
                
                # Check for SSH version
                if 'SSH-1.' in banner:
                    self.vulnerabilities.append({
                        'name': 'SSH Version 1.x Detected',
                        'type': 'service',
                        'description': 'Outdated SSH version 1.x detected',
                        'severity': 'high',
                        'location': f"{self.target}:22",
                        'cvss': 7.5
                    })
                    print(f"  ⚠️  SSH Version 1.x Detected (High)")
                    
                return banner
                
            except Exception as e:
                print(f"Error checking SSH service: {e}")
                
        return None
        
    def _check_ftp(self):
        """Check FTP service on port 21"""
        if self.port == 21 or self._check_port(21):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                sock.connect((self.target, 21))
                
                banner = sock.recv(1024).decode('utf-8').strip()
                sock.close()
                
                self.services.append({
                    'protocol': 'FTP',
                    'port': 21,
                    'version': banner,
                    'status': 'running'
                })
                
                return banner
                
            except Exception as e:
                print(f"Error checking FTP service: {e}")
                
        return None
        
    def _check_dns(self):
        """Check DNS service on port 53"""
        if self.port == 53 or self._check_port(53):
            try:
                import dns.resolver
                resolver = dns.resolver.Resolver()
                resolver.nameservers = [self.target]
                
                # Try to resolve example.com
                answers = resolver.query('example.com', 'A')
                
                self.services.append({
                    'protocol': 'DNS',
                    'port': 53,
                    'version': 'DNS',
                    'status': 'running'
                })
                
                return True
                
            except Exception as e:
                print(f"Error checking DNS service: {e}")
                
        return None
        
    def scan_ports(self, port_range='1-1000'):
        """Scan for open ports on target"""
        print(f"\n{'='*60}")
        print(f"  PORT SCANNING")
        print(f"{'='*60}")
        
        start, end = map(int, port_range.split('-'))
        
        open_ports = []
        
        for port in range(start, end + 1):
            if self._check_port(port):
                open_ports.append(port)
                print(f"  Port {port:5} is open")
                
                # Check for common services
                if port == 80:
                    self._check_http()
                elif port == 443:
                    self._check_https()
                elif port == 22:
                    self._check_ssh()
                elif port == 21:
                    self._check_ftp()
                elif port == 53:
                    self._check_dns()
                    
                # Sleep to avoid too many connections
                time.sleep(0.1)
                
        self.vulnerability_signatures['open_ports'] = [
            {
                'name': f"Port {port} Open",
                'type': 'port',
                'description': f"Port {port} is open and accessible",
                'severity': 'low' if port > 1024 else 'medium',
                'location': f"{self.target}:{port}"
            }
            for port in open_ports
        ]
        
        return open_ports
        
    def scan_services(self):
        """Scan for running services and their versions"""
        print(f"\n{'='*60}")
        print(f"  SERVICE DISCOVERY")
        print(f"{'='*60}")
        
        # Check HTTP/HTTPS
        if self._check_port(self.port):
            if self.port == 443:
                self._check_https()
            else:
                self._check_http()
                
        # Check other common services
        self._check_ssh()
        self._check_ftp()
        self._check_dns()
        
    def scan_vulnerabilities(self):
        """Scan for common vulnerabilities"""
        print(f"\n{'='*60}")
        print(f"  VULNERABILITY SCANNING")
        print(f"{'='*60}")
        
        # Check open ports
        if not self.vulnerability_signatures['open_ports']:
            self.scan_ports()
            
        # Add port vulnerabilities
        for port_sig in self.vulnerability_signatures['open_ports']:
            self.vulnerabilities.append({
                'name': port_sig['name'],
                'type': port_sig['type'],
                'description': port_sig['description'],
                'severity': port_sig['severity'],
                'location': port_sig['location'],
                'cvss': 3.0 if port_sig['severity'] == 'low' else 5.0
            })
            
    def generate_report(self):
        """Generate comprehensive vulnerability report"""
        report = {
            'scan_info': {
                'target': self.target,
                'port': self.port,
                'timestamp': datetime.now().isoformat(),
                'duration': 0,  # Not implemented
                'scanner_version': '1.0.0'
            },
            'services': self.services,
            'vulnerabilities': self.vulnerabilities
        }
        
        # Calculate risk level
        total_risk = 0
        severity_weights = {
            'critical': 10,
            'high': 7,
            'medium': 5,
            'low': 2,
            'info': 1
        }
        
        for vuln in self.vulnerabilities:
            weight = severity_weights.get(vuln['severity'], 1)
            total_risk += weight * vuln.get('cvss', 1)
            
        report['risk_score'] = total_risk
        
        return report
        
    def print_report(self):
        """Print vulnerability report to console"""
        report = self.generate_report()
        
        print(f"\n{'='*60}")
        print(f"  VULNERABILITY SCAN REPORT")
        print(f"{'='*60}")
        
        print(f"\nTarget: {report['scan_info']['target']}:{report['scan_info']['port']}")
        print(f"Scan Time: {report['scan_info']['timestamp']}")
        print(f"Risk Score: {report['risk_score']:.1f}")
        
        print(f"\nServices Running: {len(report['services'])}")
        if report['services']:
            for service in report['services']:
                print(f"  {service['protocol']} ({service['port']}): {service['version']}")
                
        print(f"\nVulnerabilities Found: {len(report['vulnerabilities'])}")
        if report['vulnerabilities']:
            severity_count = defaultdict(int)
            
            for vuln in report['vulnerabilities']:
                severity_count[vuln['severity']] += 1
                
            for severity, count in severity_count.items():
                print(f"  {severity.capitalize()}: {count}")
                
            print()
            for vuln in report['vulnerabilities']:
                print(f"  {vuln['name']} ({vuln['severity']})")
                print(f"    Location: {vuln['location']}")
                print(f"    Description: {vuln['description']}")
                print()
                
    def save_report(self, filename, format='json'):
        """Save report to file"""
        report = self.generate_report()
        
        try:
            if format == 'json':
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(report, f, indent=2, default=str)
                    
            elif format == 'xml':
                root = ET.Element('VulnerabilityReport')
                
                # Scan info
                scan_info = ET.SubElement(root, 'ScanInfo')
                ET.SubElement(scan_info, 'Target').text = report['scan_info']['target']
                ET.SubElement(scan_info, 'Port').text = str(report['scan_info']['port'])
                ET.SubElement(scan_info, 'Timestamp').text = report['scan_info']['timestamp']
                
                # Services
                services = ET.SubElement(root, 'Services')
                for service in report['services']:
                    serv_elem = ET.SubElement(services, 'Service')
                    ET.SubElement(serv_elem, 'Protocol').text = service['protocol']
                    ET.SubElement(serv_elem, 'Port').text = str(service['port'])
                    ET.SubElement(serv_elem, 'Version').text = service['version']
                    ET.SubElement(serv_elem, 'Status').text = service['status']
                    
                # Vulnerabilities
                vulnerabilities = ET.SubElement(root, 'Vulnerabilities')
                for vuln in report['vulnerabilities']:
                    vuln_elem = ET.SubElement(vulnerabilities, 'Vulnerability')
                    ET.SubElement(vuln_elem, 'Name').text = vuln['name']
                    ET.SubElement(vuln_elem, 'Type').text = vuln['type']
                    ET.SubElement(vuln_elem, 'Description').text = vuln['description']
                    ET.SubElement(vuln_elem, 'Severity').text = vuln['severity']
                    ET.SubElement(vuln_elem, 'Location').text = vuln['location']
                    ET.SubElement(vuln_elem, 'CVSS').text = str(vuln['cvss'])
                    
                tree = ET.ElementTree(root)
                tree.write(filename, encoding='utf-8', xml_declaration=True)
                
            print(f"\nReport saved to: {filename}")
            
        except Exception as e:
            print(f"\nError saving report: {e}")

def main():
    """Main function to run vulnerability scanner"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Vulnerability Scanner Tool - Detect security vulnerabilities"
    )
    
    parser.add_argument(
        "target",
        help="Target IP address or hostname to scan"
    )
    
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=80,
        help="Target port to scan (default: 80)"
    )
    
    parser.add_argument(
        "-r", "--port-range",
        default="1-1000",
        help="Port range to scan (default: 1-1000)"
    )
    
    parser.add_argument(
        "-o", "--output",
        help="Output file to save report"
    )
    
    parser.add_argument(
        "-f", "--format",
        choices=['json', 'xml'],
        default='json',
        help="Report format (default: JSON)"
    )
    
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    args = parser.parse_args()
    
    try:
        scanner = VulnerabilityScanner(
            target=args.target,
            port=args.port
        )
        
        scanner.scan_vulnerabilities()
        scanner.print_report()
        
        if args.output:
            scanner.save_report(args.output, args.format)
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
