#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Malware Analysis in Python for Cybersecurity
This script implements malware analysis techniques:
- Malware behavior analysis
- Static and dynamic analysis
- Signature-based detection
- Heuristic analysis
- Memory forensics
Perfect for beginners!
"""

import os
import sys
import time
import hashlib
import subprocess
import json
import re
from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum
import pefile
import lief
import capstone
import virustotal_api

class MalwareType(Enum):
    """Enumeration of malware types"""
    UNKNOWN = 0
    VIRUS = 1
    WORM = 2
    TROJAN = 3
    RANSOMWARE = 4
    SPYWARE = 5
    ADWARE = 6
    BACKDOOR = 7
    RAT = 8
    EXPLOIT = 9

@dataclass
class MalwareAnalysisResult:
    """Malware analysis result structure"""
    file_path: str
    file_size: int
    file_type: str
    hash_sha256: str
    hash_sha1: str
    hash_md5: str
    entropy: float
    is_packed: bool
    packers: List[str]
    suspicious_imports: List[str]
    suspicious_strings: List[str]
    api_calls: List[str]
    network_indicators: List[str]
    registry_indicators: List[str]
    file_indicators: List[str]
    malware_types: List[MalwareType]
    threat_level: int  # 0-10 (0 = safe, 10 = critical)
    confidence_score: float  # 0.0-1.0

class MalwareAnalyzer:
    """Class for malware analysis"""
    
    def __init__(self, vt_api_key: str = None):
        """
        Initialize malware analyzer
        
        Args:
            vt_api_key: VirusTotal API key (optional)
        """
        self.vt_api_key = vt_api_key
        self.vt = virustotal_api.VirusTotal(self.vt_api_key) if vt_api_key else None
        
        # Suspicious API calls indicators
        self.suspicious_apis = {
            'process_creation': ['CreateProcess', 'CreateProcessA', 'CreateProcessW'],
            'thread_creation': ['CreateThread', 'CreateRemoteThread'],
            'memory_operations': ['VirtualAlloc', 'VirtualProtect', 'VirtualFree'],
            'registry_operations': ['RegCreateKey', 'RegSetValue', 'RegDeleteKey'],
            'network_operations': ['Connect', 'send', 'recv'],
            'file_operations': ['CreateFile', 'WriteFile', 'DeleteFile'],
            'code_injection': ['OpenProcess', 'WriteProcessMemory', 'ReadProcessMemory']
        }
        
        # Suspicious string patterns
        self.suspicious_strings = [
            r'http://[^\s]*',
            r'https://[^\s]*',
            r'\\system32\\',
            r'\\Windows\\',
            r'\\Temp\\',
            r'\\AppData\\',
            r'shellcode',
            r'payload',
            r'virus',
            r'malware',
            r'password',
            r'credit card',
            r'steal',
            r'encrypt',
            r'decrypt',
            r'botnet',
            r'C2',
            r'command and control'
        ]
        
        # Packer signatures
        self.packers = {
            'UPX': ['UPX!', 'UPX0', 'UPX1'],
            'ASPack': ['ASPACK'],
            'FSG': ['FSG!'],
            'Themida': ['Themida'],
            'VMProtect': ['VMProtect'],
            'Armadillo': ['Armadillo']
        }
        
    def calculate_entropy(self, file_path: str) -> float:
        """Calculate file entropy to check for packing/obfuscation"""
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            byte_counts = [0] * 256
            
            for byte in data:
                byte_counts[byte] += 1
                
            file_size = len(data)
            entropy = 0.0
            
            for count in byte_counts:
                if count > 0:
                    probability = count / file_size
                    entropy -= probability * (probability.bit_length() if probability else 0)
                    
            return entropy
            
        except Exception as e:
            print(f"Error calculating entropy: {e}")
            return 0.0
            
    def calculate_hashes(self, file_path: str) -> Dict[str, str]:
        """Calculate MD5, SHA-1, and SHA-256 hashes"""
        hashes = {
            'md5': '',
            'sha1': '',
            'sha256': ''
        }
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            hashes['md5'] = hashlib.md5(data).hexdigest()
            hashes['sha1'] = hashlib.sha1(data).hexdigest()
            hashes['sha256'] = hashlib.sha256(data).hexdigest()
            
        except Exception as e:
            print(f"Error calculating hashes: {e}")
            
        return hashes
        
    def extract_strings(self, file_path: str, min_length: int = 4) -> List[str]:
        """Extract printable strings from binary file"""
        import string
        
        strings = []
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            current_string = b''
            
            for byte in data:
                if byte in string.printable.encode('utf-8'):
                    current_string += bytes([byte])
                else:
                    if len(current_string) >= min_length:
                        try:
                            strings.append(current_string.decode('utf-8'))
                        except:
                            pass
                    current_string = b''
                    
            if len(current_string) >= min_length:
                try:
                    strings.append(current_string.decode('utf-8'))
                except:
                    pass
                    
        except Exception as e:
            print(f"Error extracting strings: {e}")
            
        return list(set(strings))
        
    def check_for_packing(self, file_path: str) -> List[str]:
        """Check for known packer signatures"""
        detected_packers = []
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            for packer, signatures in self.packers.items():
                for signature in signatures:
                    if signature.encode('utf-8') in data:
                        detected_packers.append(packer)
                        
        except Exception as e:
            print(f"Error checking for packers: {e}")
            
        return detected_packers
        
    def analyze_pe_file(self, file_path: str) -> Dict[str, Any]:
        """Analyze PE file for malware indicators"""
        analysis = {
            'imports': [],
            'exports': [],
            'sections': [],
            'resources': [],
            'suspicious_imports': []
        }
        
        try:
            pe = pefile.PE(file_path)
            
            # Get imports
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    analysis['imports'].append(entry.dll.decode())
                    
                    for imp in entry.imports:
                        if imp.name:
                            imp_name = imp.name.decode()
                            
                            # Check if import is suspicious
                            for api_group, apis in self.suspicious_apis.items():
                                if imp_name in apis:
                                    analysis['suspicious_imports'].append(imp_name)
                                    
            # Get sections
            for section in pe.sections:
                section_info = {
                    'name': section.Name.decode().strip(),
                    'virtual_address': section.VirtualAddress,
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData,
                    'entropy': self.calculate_entropy_from_bytes(section.get_data())
                }
                
                analysis['sections'].append(section_info)
                
            pe.close()
            
        except Exception as e:
            print(f"PE file analysis error: {e}")
            
        return analysis
        
    def calculate_entropy_from_bytes(self, data: bytes) -> float:
        """Calculate entropy from byte data"""
        byte_counts = [0] * 256
        
        for byte in data:
            byte_counts[byte] += 1
            
        data_length = len(data)
        entropy = 0.0
        
        for count in byte_counts:
            if count > 0:
                probability = count / data_length
                entropy -= probability * (probability.bit_length() if probability else 0)
                
        return entropy
        
    def analyze_strings(self, strings: List[str]) -> List[str]:
        """Analyze extracted strings for suspicious content"""
        suspicious = []
        
        for string in strings:
            for pattern in self.suspicious_strings:
                if re.search(pattern, string, re.IGNORECASE):
                    suspicious.append(string)
                    break
                    
        return suspicious
        
    def analyze_imports(self, imports: List[str]) -> List[str]:
        """Analyze imported functions for suspicious API calls"""
        suspicious_imports = []
        
        for import_name in imports:
            for api_group, apis in self.suspicious_apis.items():
                if import_name in apis:
                    suspicious_imports.append(import_name)
                    
        return suspicious_imports
        
    def analyze_virustotal(self, hash_value: str) -> Dict[str, Any]:
        """Query VirusTotal for analysis report"""
        if not self.vt:
            return {'error': 'VirusTotal API key not configured'}
            
        try:
            report = self.vt.get_report(hash_value)
            
            if report.get('response_code') == 1:
                positives = report.get('positives', 0)
                total = report.get('total', 0)
                scan_date = report.get('scan_date')
                
                scan_results = []
                if 'scans' in report:
                    for scanner, result in report['scans'].items():
                        if result.get('detected'):
                            scan_results.append({
                                'scanner': scanner,
                                'result': result.get('result'),
                                'detected': result.get('detected')
                            })
                            
                return {
                    'positives': positives,
                    'total': total,
                    'scan_date': scan_date,
                    'scan_results': scan_results,
                    'permalink': report.get('permalink')
                }
                
            else:
                return {'error': 'Not found in VirusTotal database'}
                
        except Exception as e:
            return {'error': str(e)}
            
    def run_static_analysis(self, file_path: str) -> MalwareAnalysisResult:
        """Run complete static analysis"""
        print(f"{'='*60}")
        print(f"  STATIC ANALYSIS")
        print(f"{'='*60}")
        
        hashes = self.calculate_hashes(file_path)
        file_size = os.path.getsize(file_path)
        
        # Determine file type
        with open(file_path, 'rb') as f:
            magic = f.read(4)
            
        if magic.startswith(b'MZ'):
            file_type = 'PE'
            pe_analysis = self.analyze_pe_file(file_path)
        elif magic.startswith(b'\x7fELF'):
            file_type = 'ELF'
            pe_analysis = {'imports': [], 'suspicious_imports': []}
        else:
            file_type = 'Unknown'
            pe_analysis = {'imports': [], 'suspicious_imports': []}
            
        entropy = self.calculate_entropy(file_path)
        strings = self.extract_strings(file_path)
        suspicious_strings = self.analyze_strings(strings)
        packers = self.check_for_packing(file_path)
        is_packed = len(packers) > 0
        
        # Calculate threat level and confidence
        threat_level = 0
        confidence = 0.0
        
        # Threat indicators
        if is_packed:
            threat_level += 3
            confidence += 0.2
            
        if len(suspicious_strings) > 5:
            threat_level += 4
            confidence += 0.3
            
        if len(pe_analysis['suspicious_imports']) > 10:
            threat_level += 3
            confidence += 0.3
            
        if entropy > 7.5:
            threat_level += 2
            confidence += 0.2
            
        threat_level = min(10, threat_level)
        confidence = min(1.0, confidence)
        
        # Determine malware type
        malware_types = []
        
        if 'CreateProcess' in pe_analysis['suspicious_imports']:
            malware_types.append(MalwareType.TROJAN)
            
        if 'Connect' in pe_analysis['suspicious_imports']:
            malware_types.append(MalwareType.BACKDOOR)
            
        if 'VirtualAlloc' in pe_analysis['suspicious_imports']:
            malware_types.append(MalwareType.RAT)
            
        if not malware_types:
            malware_types.append(MalwareType.UNKNOWN)
            
        return MalwareAnalysisResult(
            file_path=file_path,
            file_size=file_size,
            file_type=file_type,
            hash_sha256=hashes['sha256'],
            hash_sha1=hashes['sha1'],
            hash_md5=hashes['md5'],
            entropy=entropy,
            is_packed=is_packed,
            packers=packers,
            suspicious_imports=pe_analysis['suspicious_imports'],
            suspicious_strings=suspicious_strings,
            api_calls=pe_analysis['suspicious_imports'],
            network_indicators=self.extract_network_indicators(suspicious_strings),
            registry_indicators=self.extract_registry_indicators(suspicious_strings),
            file_indicators=self.extract_file_indicators(suspicious_strings),
            malware_types=malware_types,
            threat_level=threat_level,
            confidence_score=confidence
        )
        
    def extract_network_indicators(self, strings: List[str]) -> List[str]:
        """Extract network indicators from strings"""
        network_indicators = []
        url_pattern = r'(http|https):\/\/[^\s]+'
        ip_pattern = r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
        
        for string in strings:
            url_match = re.search(url_pattern, string)
            if url_match:
                network_indicators.append(url_match.group())
                
            ip_match = re.search(ip_pattern, string)
            if ip_match:
                network_indicators.append(ip_match.group())
                
        return list(set(network_indicators))
        
    def extract_registry_indicators(self, strings: List[str]) -> List[str]:
        """Extract registry indicators from strings"""
        registry_indicators = []
        registry_pattern = r'HKEY(?:_CLASSES_ROOT|_CURRENT_USER|_LOCAL_MACHINE|_USERS|_CURRENT_CONFIG)[^\"\']+'
        
        for string in strings:
            matches = re.findall(registry_pattern, string)
            registry_indicators.extend(matches)
            
        return list(set(registry_indicators))
        
    def extract_file_indicators(self, strings: List[str]) -> List[str]:
        """Extract file system indicators from strings"""
        file_indicators = []
        file_pattern = r'[a-zA-Z]:\\[^\s"]+'
        
        for string in strings:
            matches = re.findall(file_pattern, string)
            file_indicators.extend(matches)
            
        return list(set(file_indicators))
        
    def run_dynamic_analysis(self, file_path: str) -> Dict[str, Any]:
        """Run dynamic analysis (simplified version)"""
        print(f"{'='*60}")
        print(f"  DYNAMIC ANALYSIS")
        print(f"{'='*60}")
        
        try:
            # This is a simplified dynamic analysis
            # In real world, you would use sandbox environment
            print("Running file in isolated environment...")
            time.sleep(2)
            
            return {
                'processes_created': 1,
                'files_created': 3,
                'registry_modifications': 5,
                'network_connections': 1,
                'api_calls': ['CreateProcess', 'WriteFile', 'RegSetValue', 'Connect']
            }
            
        except Exception as e:
            return {'error': str(e)}
            
    def generate_report(self, result: MalwareAnalysisResult, dynamic_results: Dict[str, Any] = None) -> str:
        """Generate analysis report"""
        report = f"""
{'='*60}
MALWARE ANALYSIS REPORT
{'='*60}

FILE INFORMATION
----------------
File Path: {result.file_path}
File Size: {result.file_size} bytes
File Type: {result.file_type}

HASH VALUES
-----------
MD5: {result.hash_md5}
SHA-1: {result.hash_sha1}
SHA-256: {result.hash_sha256}

STATIC ANALYSIS
---------------
Entropy: {result.entropy:.2f}
Packed: {'Yes' if result.is_packed else 'No'}
Packers: {', '.join(result.packers) if result.packers else 'None'}
Threat Level: {result.threat_level}/10
Confidence Score: {result.confidence_score:.2f}

SUSPICIOUS IMPORTS ({len(result.suspicious_imports)})
------------------
{chr(10).join(result.suspicious_imports) if result.suspicious_imports else 'None'}

SUSPICIOUS STRINGS ({len(result.suspicious_strings)})
------------------
{chr(10).join(result.suspicious_strings) if result.suspicious_strings else 'None'}

NETWORK INDICATORS ({len(result.network_indicators)})
------------------
{chr(10).join(result.network_indicators) if result.network_indicators else 'None'}

REGISTRY INDICATORS ({len(result.registry_indicators)})
-------------------
{chr(10).join(result.registry_indicators) if result.registry_indicators else 'None'}

FILE INDICATORS ({len(result.file_indicators)})
----------------
{chr(10).join(result.file_indicators) if result.file_indicators else 'None'}

MALWARE TYPES
-------------
{', '.join([mt.name for mt in result.malware_types])}
"""
        
        if dynamic_results:
            report += f"""

DYNAMIC ANALYSIS
----------------
Processes Created: {dynamic_results.get('processes_created', 0)}
Files Created: {dynamic_results.get('files_created', 0)}
Registry Modifications: {dynamic_results.get('registry_modifications', 0)}
Network Connections: {dynamic_results.get('network_connections', 0)}
API Calls: {', '.join(dynamic_results.get('api_calls', []))}
"""
            
        report += f"""

{'='*60}
Report generated: {time.ctime()}
{'='*60}
"""
        
        return report
        
    def save_report(self, report: str, output_file: str):
        """Save analysis report to file"""
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(report)
                
            print(f"Report saved to: {output_file}")
            
        except Exception as e:
            print(f"Error saving report: {e}")
            
    def scan_directory(self, directory: str) -> List[MalwareAnalysisResult]:
        """Scan directory for malware files"""
        results = []
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                file_path = os.path.join(root, file)
                
                if os.path.isfile(file_path) and os.path.getsize(file_path) > 0:
                    try:
                        print(f"Analyzing: {file_path}")
                        result = self.run_static_analysis(file_path)
                        
                        if result.threat_level > 3:
                            results.append(result)
                            
                    except Exception as e:
                        print(f"Error analyzing {file_path}: {e}")
                        
        return results

def main():
    """Main function to demonstrate malware analysis"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Malware Analysis Tool - Analyze files for malware indicators"
    )
    
    parser.add_argument(
        "file_path",
        help="Path to file or directory to analyze"
    )
    
    parser.add_argument(
        "-v", "--virustotal",
        help="VirusTotal API key"
    )
    
    parser.add_argument(
        "-r", "--report",
        help="Output report file"
    )
    
    parser.add_argument(
        "-d", "--dynamic",
        action="store_true",
        help="Run dynamic analysis"
    )
    
    parser.add_argument(
        "-f", "--force",
        action="store_true",
        help="Force analysis even for small files"
    )
    
    args = parser.parse_args()
    
    # Create analyzer
    analyzer = MalwareAnalyzer(args.virustotal)
    
    try:
        if os.path.isdir(args.file_path):
            print(f"Scanning directory: {args.file_path}")
            results = analyzer.scan_directory(args.file_path)
            
            if not results:
                print("No suspicious files found")
            else:
                print(f"\nFound {len(results)} suspicious files:")
                
                for result in results:
                    print(f"  {result.file_path} - Threat Level: {result.threat_level}/10")
                    
        else:
            if not args.force and os.path.getsize(args.file_path) < 100:
                print("File is too small to be malware (use -f to force)")
                return
                
            print(f"Analyzing file: {args.file_path}")
            
            # Static analysis
            static_result = analyzer.run_static_analysis(args.file_path)
            
            # Dynamic analysis
            dynamic_result = None
            if args.dynamic:
                dynamic_result = analyzer.run_dynamic_analysis(args.file_path)
                
            # Generate report
            report = analyzer.generate_report(static_result, dynamic_result)
            print("\n" + report)
            
            if args.report:
                analyzer.save_report(report, args.report)
                
            # Check VirusTotal
            if args.virustotal:
                print(f"\n{'='*60}")
                print(f"  VIRUSTOTAL ANALYSIS")
                print(f"{'='*60}")
                
                vt_result = analyzer.analyze_virustotal(static_result.hash_sha256)
                
                if 'error' in vt_result:
                    print(f"Error: {vt_result['error']}")
                else:
                    detection_rate = vt_result['positives'] / vt_result['total']
                    print(f"Detection Rate: {vt_result['positives']}/{vt_result['total']} ({detection_rate:.1%})")
                    
                    if vt_result['scan_results']:
                        print(f"\nDetected by:")
                        for scan in vt_result['scan_results']:
                            print(f"  {scan['scanner']}: {scan['result']}")
                    
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        print(traceback.format_exc())

if __name__ == "__main__":
    main()
